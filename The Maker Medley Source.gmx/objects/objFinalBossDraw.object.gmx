<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprCamera</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-6</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>bkSquareColor = make_color_rgb(31, 77, 52); //used only if the Undertale and finalBossBK shaders fail
undertale = (room == rFinalBoss_3); //whether to attempt to change the background for Phase 3 Undertale
hitchBackCol = make_color_rgb(77, 143, 185); //Sudnep avoidance failsafe
hitchBackBlendAmt = 0;
hitchBackDec = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Colorize background if in Sudnep avoidance
// (done here to allow loading into room)
if (view_yview &lt; 608 || global.roomSaveTo == 5){  // global.roomSaveTo check allows loading into room
    hitchBackBlendAmt = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (hitchBackDec &amp;&amp; hitchBackBlendAmt &gt; 0){
    hitchBackBlendAmt = max(hitchBackBlendAmt - 0.04, 0);
    if (hitchBackBlendAmt &lt;= 0){
        hitchBackDec = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (undertale &amp;&amp; global.dead){
    //if the player dies during the undertale phase, we shouldn't have the green background visible
    draw_set_colour(c_black);
    draw_rectangle(view_xview-256, view_yview-256, view_xview+1056, view_yview+864, false);
    draw_set_colour(c_white);
}else{
    if (global.finalBKEnabled &amp;&amp; (!undertale || global.hueshiftEnabled)){
        if (!surface_exists(global.sharedSurf)){
            global.sharedSurf = surface_create(800, 608);
        }
        if (surface_exists(global.sharedSurf)){
            surface_set_target(global.sharedSurf); //keeps the effect consistant regardless of where it's drawn
            //draw_clear_alpha(c_black, 1);
            
            shader_set(shdFinalBossBK);
            shader_set_uniform_f(global.finalbossHandle, global.countPersistent * 0.0025);
            shader_set_uniform_f(global.finalbossHandle2, 800, 608);
            texture_set_repeat(true);
            draw_rectangle(0, 0, 800, 608, false);
            texture_set_repeat(false);
            
            shader_reset();
            surface_reset_target();
            
            if (surface_exists(global.sharedSurf)){
                if (undertale &amp;&amp; global.hueshiftEnabled){
                    draw_set_colour(c_black);
                    draw_rectangle(-800, -608, 1600, 1216, false);
                    draw_set_colour(c_white);
                    
                    shader_set(shdHueShift);
                    shader_set_uniform_f(global.hueshiftHandle, 5/6 * pi);
                    draw_surface_part_ext(global.sharedSurf, 11 / max(view_wview/800, 0.01), 12, 789-11, 242, 11, 12, view_wview/800, view_hview/608, c_white, 1);
                    shader_reset();
                }else if (hitchBackBlendAmt &gt; 0 &amp;&amp; global.hueshiftEnabled){
                    var rotCoords = scrChangeOrigin(0, 0, 400, 304, -view_angle);
                    draw_surface_ext(global.sharedSurf, max(x, view_xview) + (400 + rotCoords[0]) * view_wview/800, view_yview + (304 + rotCoords[1]) * view_hview/608, view_wview/800, view_hview/608, -view_angle, c_white, 1);
                    
                    shader_set(shdHueShift);
                    shader_set_uniform_f(global.hueshiftHandle, 0.41 * pi);
                    draw_surface_ext(global.sharedSurf, max(x, view_xview) + (400 + rotCoords[0]) * view_wview/800, view_yview + (304 + rotCoords[1]) * view_hview/608, view_wview/800, view_hview/608, -view_angle, c_white, hitchBackBlendAmt);
                    shader_reset();
                }else{
                    var rotCoords = scrChangeOrigin(0, 0, 400, 304, -view_angle);
                    draw_surface_ext(global.sharedSurf, max(x, view_xview) + (400 + rotCoords[0]) * view_wview/800, view_yview + (304 + rotCoords[1]) * view_hview/608, view_wview/800, view_hview/608, -view_angle, c_white, 1);
                    if (hitchBackBlendAmt &gt; 0 &amp;&amp; !global.hueshiftEnabled){
                        draw_set_color(hitchBackCol)
                        draw_set_alpha(hitchBackBlendAmt * 0.5);
                        draw_rectangle(-800, -608, 1600, 1216, false);
                        draw_set_alpha(1);
                        draw_set_color(c_white);
                    }
                }
            }
        }
    }else{
        if (!undertale || global.hueshiftEnabled){
            if (!surface_exists(global.sharedSurf)){
                global.sharedSurf = surface_create(800, 608);
            }
            if (surface_exists(global.sharedSurf)){
                surface_set_target(global.sharedSurf);  // needed for view rotations
                draw_clear_alpha(c_black, 0); //Undertale
                
                var _resetShader = false;
                if (undertale &amp;&amp; global.hueshiftEnabled){
                    shader_set(shdHueShift);
                    shader_set_uniform_f(global.hueshiftHandle, -7*pi/6);
                    _resetShader = true;
                }
                
                draw_background_tiled(bkFinalScribbleFailsafe, 11 / max(view_wview/800, 0.01), (floor(0.875*global.countPersistent) - 12) mod 512);
                
                if (_resetShader){
                    shader_reset();
                    _resetShader = false;
                }
                
                if (hitchBackBlendAmt &gt; 0 &amp;&amp; !global.hueshiftEnabled){
                    draw_set_color(hitchBackCol)
                    draw_set_alpha(hitchBackBlendAmt * 0.5);
                    draw_set_color_write_enable(1, 1, 1, 0);
                    draw_rectangle(-800, -608, 1600, 1216, false);
                    draw_set_color_write_enable(1, 1, 1, 1);
                    draw_set_alpha(1);
                    draw_set_color(c_white);
                }
                surface_reset_target();
                
                if (surface_exists(global.sharedSurf)){
                    var rotCoords = scrChangeOrigin(0, 0, 400, 304, -view_angle);
                    if (undertale &amp;&amp; global.hueshiftEnabled){
                        draw_surface_part_ext(global.sharedSurf, 11 / max(view_wview/800, 0.01), 12, 789-11, 242, 11, 12, view_wview/800, view_hview/608, c_white, 1);
                    }else{
                        draw_surface_ext(global.sharedSurf, max(x, view_xview) + (400 + rotCoords[0]) * view_wview/800, view_yview + (304 + rotCoords[1]) * view_hview/608, view_wview/800, view_hview/608, -view_angle, c_white, 1);
                        if (hitchBackBlendAmt &gt; 0 &amp;&amp; global.hueshiftEnabled){
                            shader_set(shdHueShift);
                            shader_set_uniform_f(global.hueshiftHandle, 0.41 * pi);
                            draw_surface_ext(global.sharedSurf, max(x, view_xview) + (400 + rotCoords[0]) * view_wview/800, view_yview + (304 + rotCoords[1]) * view_hview/608, view_wview/800, view_hview/608, -view_angle, c_white, hitchBackBlendAmt);
                            shader_reset();
                        }
                    }
                }else{
                    if (undertale){
                        draw_set_colour(c_black);
                        draw_rectangle(-800, -608, 1600, 1216, false);
                        draw_set_colour(c_white);
                        
                        scrDrawTiledArea(bkFinalScribbleFailsafe, 0, -((floor(0.875*global.countPersistent) - (12 / max(view_hview/608, 0.01))) mod 512), 11 / max(view_wview/800, 0.01), view_yview, (view_xview + 11) + (778 / max(view_wview/800, 0.01)), view_yview + (282 / max(view_hview/608, 0.01)));
                    }else{
                        scrDrawTiledArea(bkFinalScribbleFailsafe, 0,  ((floor(0.875*global.countPersistent) - (12 / max(view_hview/608, 0.01))) mod 512), max(x, view_xview) - 0.5*view_wview, view_yview - 0.5*view_hview, max(x, view_xview) + 1.5*view_wview, view_yview + 1.5*view_hview); 
                    }
                }
            }
        }else{
            draw_set_colour(c_black);
            draw_rectangle(-800, -608, 1600, 1216, false);
            draw_set_colour(c_white);
            draw_set_color(bkSquareColor);
            draw_line_width(11 -0.5, 10 -0.5, 789 -0.5, 10 -0.5, 3);
            draw_line_width(11 -0.5, 130 -0.5, 789 -0.5, 130 -0.5, 3);
            draw_line_width(11 -0.5, 252 -0.5, 789 -0.5, 252 -0.5, 3);
            
            for(var i=0;i&lt;7;i++){
                draw_line_width(12 + 129.3333*i  -0.5, 12  -0.5, 12 + 129.3333*i  -0.5, 254   -0.5, 3);
            }
            draw_set_color(c_white);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

if (room == rFinalBoss_1){
    //Additive Blending
    if (instance_exists(objFinalKnightFireworkTrail) || instance_exists(objFinalKnightFireworkExplosion) || instance_exists(objFinalKnightFireworkParticle)){
        draw_set_blend_mode(bm_add);
        with (objFinalKnightFireworkTrail)
            draw_self();
        with (objFinalKnightFireworkExplosion)
            draw_self();
        with (objFinalKnightFireworkParticle)
            event_perform(ev_draw, 0);
        draw_set_blend_mode(bm_normal);
    }
}else if (room == rFinalBoss_4){
    var _cornerIndex, _beamIndex;
    _cornerIndex = (global.countPersistent*6/50) mod 6;
    _beamIndex = abs(2 - ((global.countPersistent*6/50) + 2) mod 4);
    with (objBetterBlock){
        draw_sprite(sprFinalTiles, _cornerIndex, bbox_left + 16, bbox_top + 16);
        draw_sprite(sprFinalTiles, 6 + _beamIndex, bbox_left + 48, bbox_top + 16);
        for (var i = 80; i &lt;= sprite_width - 80; i += 32){
            draw_sprite(sprFinalTiles, 9 + _beamIndex, bbox_left + i, bbox_top + 16);
        }
        
        draw_sprite(sprFinalTiles, 12 + _beamIndex, bbox_left + 16 + (sprite_width-64), bbox_top + 16);
        draw_sprite(sprFinalTiles, _cornerIndex, bbox_left + (sprite_width - 16), bbox_top + 16);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
