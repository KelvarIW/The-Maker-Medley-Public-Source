<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprGeezerPacPhantom</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-7</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>color = 0; // 0-3
animIndex = 0;
chase = false;
showLetter = false;  // color blind assistance
targetX = 0;
targetY = 0;
distU = 0;
distD = 0;
distL = 0;
distR = 0;
playerDir = 0; //Up if player is moving up, otherwise objPlayer.xScale
tileX = 8;
tileY = 13;
tileXPrev = 8;
tileYPrev = 13;
image_speed = 0;
sprite_index = sprGeezerPacPhantom;
fade = false;
shotAnimTimer = -1;
shotAnimLength = 12;
drawXOff = 0;  // used to determine if we are drawing its shadow (so we don't need to draw the eyes)
if (!(global.practicing || global.practiceWaypointStart == 1)){  // don't play the throw sound effect at the start of practice mode
    audio_sound_gain(audio_play_sound(sndGeezerThrow, 0, 0), 1.5, 0); //audio_play_sound(sndGeezerBoo, 0, 0);
}

// Initial throw
image_xscale = 7;
image_yscale = image_xscale;
destX = 328 - 12;
destY = 349;
speed = 3.6;
gravity = 0.165;

//Unimplemented
frightened = false;
frightTimer = -1;
eaten = false;
warping = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>targetX = 12;
targetY = 9;
move_towards_point(400, 272, 4);
//showLetter = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (gravity &gt; 0){
    if (y &gt;= 349){
        y = 349;
        speed = 0;
        gravity = 0;
        direction = 270;
    }
}else if (!warping){
    if (!chase){
        if (y &lt;= 272){
            y = 272;
            x = 400
            speed = 0;
            chase = true; //will run following block
        }
    }
    if (chase){  // chase means active, scatter overrides position
        var _inBox = (x &gt; 288 &amp;&amp; x &lt; 512 &amp;&amp; y &gt; 320 &amp;&amp; y &lt; 384);
        
        var _scatterOverride = false;
        if (instance_exists(objGeezerPacCtrl)){
            _scatterOverride = objGeezerPacCtrl.scatter;
        }
        // Blinky "scatter mode" override
        if (_scatterOverride &amp;&amp; color == 0){
            if (!buff() &amp;&amp; instance_number(objMakerCoin) &lt;= 20){  // chase relentlessly if &lt;= 20 coins
                _scatterOverride = false;
            }else if (buff() &amp;&amp; instance_number(objMakerCoin) &lt;= 30){  // BUFF: threshold raised to &lt;= 30 coins
                _scatterOverride = false;
            }
        }
        
        if (!_inBox &amp;&amp; (!frightened &amp;&amp; !eaten)){  // `fightened` and `eaten` checks are a relic from development
            if ((hspeed &lt; 0 &amp;&amp; x &lt;= tileX*32 - 16) || (hspeed &gt; 0 &amp;&amp; x &gt;= tileX*32 + 48) || (vspeed &lt; 0 &amp;&amp; y &lt;= tileY*32 - 16) || (vspeed &gt; 0 &amp;&amp; y &gt;= tileY*32 + 48)){
                tileX = x div 32;
                tileY = y div 32;
                if (hspeed != 0) x = tileX*32 + 16;
                if (vspeed != 0) y = tileY*32 + 16;
                
                if (_scatterOverride){  // must use local variable for Blinky behavior
                    switch(color){  // same corners as Pac-Man AI 
                        case 0:  // Blinky
                            targetX = 24;
                            targetY = 0;
                        break;
                        case 1:  // Pinky
                            targetX = 0;
                            targetY = 0;
                        break;
                        case 2:  // Inky
                            targetX = 24;
                            targetY = 18;
                        break;
                        case 3:  // Clyde
                            targetX = 0;
                            targetY = 18;
                        break;
                    }
                }else{
                    if (instance_exists(objPlayer)){
                        if (abs(objPlayer.vspeed) &gt;= 1){
                            if (objPlayer.vspeed &lt; 0){
                                playerDir = 90;
                            }else{
                                playerDir = 270;
                            }
                        }else{
                            playerDir = 90 - 90*objPlayer.xScale
                        }
                        
                        targetX = objPlayer.x div 32;
                        targetY = objPlayer.y div 32;
                        
                        switch(color){  // we're doing Pac-Man AI
                            case 0:  // Blinky
                                targetX = objPlayer.x div 32;
                                targetY = objPlayer.y div 32;
                            break;
                            case 1:  // Pinky
                                //If the Player is facing left, targetX -= 4
                                //If the Player is facing right, targetX += 4
                                //If the Player is facing up, targetX -= 4 &amp; targetY -= 4
                                
                                if (playerDir == 90) targetY -= 4;
                                if (playerDir == 0){targetX += 4;}else{targetX -= 4;}
                            break;
                            case 2:  // Inky
                                //Half of Pinky's offset, + vector from Player to Blinky rotated 180
                                if (playerDir == 90) targetY -= 2;
                                if (playerDir == 0) targetX += 2;
                                else targetX -= 2;
                                with (object_index){
                                    if (color == 0){ //Blinky
                                        other.targetX -= (x - objPlayer.x) div 32; //no need for trigonometry
                                        other.targetY -= (y - objPlayer.y) div 32; //180 degree rotation = (-x, -y)
                                    }
                                }
                            break;
                            case 3:  // Clyde
                                if (point_distance(x, y, objPlayer.x, objPlayer.y) &lt;= 256){  // 8 tiles or fewer
                                    targetX = 0;
                                    targetY = 18;
                                }else{
                                    targetX = roundSane(objPlayer.x / 32);
                                    targetY = roundSane(objPlayer.y / 32);
                                }
                            break;
                        }
                    }
                }
                
                
                event_user(0);  // Tile-Based Movement (after calculating new target
            }
        }
        speed = 3;
    }
}
if (warping){
    if ((x &gt;= 816 &amp;&amp; hspeed &gt; 0) || (x &lt;= -16 &amp;&amp; hspeed &lt; 0)){
        if (x &gt;= 816){x = 16;direction = 0;tileX = 0;}
        if (x &lt;= -16){x = 784;direction = 180;tileX = 24;}
        warping = false;
    }
}else{
    if ((x &gt; 784 &amp;&amp; hspeed &gt; 0) || (x &lt; 16 &amp;&amp; hspeed &lt; 0)){
        warping = true;
    }
}

if (image_xscale &gt; 1){
    image_xscale -= 1/3;
    if (image_xscale &lt; 1) image_xscale = 1;
    image_yscale = image_xscale;
}

if (fade){
    image_alpha -= 0.25;
    if (image_alpha &lt;= 0) instance_destroy();
}


if (shotAnimTimer &gt;= 0){
    shotAnimTimer += 1;
    if (shotAnimTimer &gt;= shotAnimLength){
        shotAnimTimer = -1;
    }
}
tileXPrev = tileX;
tileYPrev = tileY;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objBullet">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (objBullet){
    x = xprevious;
    scrMoveContactObject(sign(hspeed), 0, abs(hspeed), other);
    instance_destroy();
}
shotAnimTimer = 0;  // will increment to 1 before sprite is drawn - this is accurate to IWMaker
var _snd = audio_play_sound(sndGeezerGhostShot, 0, 0);
audio_sound_pitch(_snd, PITCH_FLUCT);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlayer">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!fade) scrKillPlayer();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Tile-Based Movement

//Check distance to target X and Y + Can not move backwards or into a solid tile
if (direction != 0 &amp;&amp; !place_meeting(x - 32, y, objBlock)) distL = point_distance(x - 32, y, targetX*32 + 16, targetY*32 + 16);
else distL = 3000;
if (direction != 90 &amp;&amp; !place_meeting(x, y + 32, objBlock)) distD = point_distance(x, y + 32, targetX*32 + 16, targetY*32 + 16);
else distD = 3000;
if (direction != 180 &amp;&amp; !place_meeting(x + 32, y, objBlock)) distR = point_distance(x + 32, y, targetX*32 + 16, targetY*32 + 16);
else distR = 3000;
if (direction != 270 &amp;&amp; !place_meeting(x, y - 32, objBlock)) distU = point_distance(x, y - 32, targetX*32 + 16, targetY*32 + 16);
else distU = 3000;

//Priority: U L D (R)
switch(min(distU, distL, distD, distR)){
    case distU:
        direction = 90;
        break;
    case distL:
        direction = 180;
        break;
    case distD:
        direction = 270;
        break;
    case distR:
        direction = 0;
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//no need to worry about the "eaten" and "frightened" states since that mechanic has been scrapped
//if (!eaten &amp;&amp; !frightened){
    var t_dir = (direction + 45) mod 360;
    if (gravity != 0){
        t_dir = 270;
    }else if (speed == 0 &amp;&amp; instance_exists(objPlayer) &amp;&amp; (instance_exists(objGeezerPacCtrl) &amp;&amp; objGeezerPacCtrl.active)){
        t_dir = (point_direction(x, y, objPlayer.x, objPlayer.y) + 45) mod 360;
    }
    
    var _blinkTimer = (global.count mod 159);
    var _eyeSprW = 14, _eyeSprH = 10;
    var _eyeWidth = _eyeSprW*image_xscale, _eyeHeight = _eyeSprH*image_yscale;
    var _xscaleMult, _yscaleMult;  // shot animation
    if (shotAnimTimer &gt;= 0){
        _xscaleMult = lerp(1.375, 1, sin(shotAnimTimer/shotAnimLength * pi/2));
        _yscaleMult = lerp(0.6875, 1, sin(shotAnimTimer/shotAnimLength * pi/2));
    }else{
        _xscaleMult = 1;
        _yscaleMult = 1;
    }
    
    draw_sprite_ext(sprite_index, color*4 + ((global.count mod 20) div 5), x, y, image_xscale * _xscaleMult, image_yscale * _yscaleMult, 0, c_white, 1);
    
    if (drawXOff == 0){  // if drawing a shadow, we don't need to add the eyes
        if (_blinkTimer &lt; 147 || !chase){  // eyes open
            draw_sprite_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), x, y, image_xscale, image_yscale, 0, c_white, 1);
        }else if (_blinkTimer &gt;= 151 &amp;&amp; _blinkTimer &lt; 155){  // eyes shut
            draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, 0, _eyeSprW, 2, x - (_eyeWidth/2), y - _eyeHeight + 3, image_xscale, image_yscale, c_white, 1);
            draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, _eyeSprH-2, _eyeSprW, 2, x - (_eyeWidth/2), y - _eyeHeight + 3 + 2, image_xscale, image_yscale, c_white, 1);
        }else{  // in-between
            draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, 0, _eyeSprW, 2, x - (_eyeWidth/2), y - _eyeHeight + 2, image_xscale, image_yscale, c_white, 1);
            draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, floor((_eyeSprH-2)/2), _eyeSprW, 2, x - (_eyeWidth/2), y - _eyeHeight + 2 + 2, image_xscale, image_yscale, c_white, 1);
            draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, _eyeSprH-2, _eyeSprW, 2, x - (_eyeWidth/2), y - _eyeHeight + 2 + 2 + 2, image_xscale, image_yscale, c_white, 1);
        }
    }
    
    //The ghost is drawn twice if screenwrapping - once in its current position and once at the opposite x position
    //  same code as above, but replace `x` with `x - 800*sign(x - 400)`
    if (warping){
        draw_sprite_ext(sprite_index, color*4 + ((global.count mod 20) div 5), x - 800*sign(x - 400), y, image_xscale * _xscaleMult, image_yscale * _yscaleMult, 0, c_white, 1);
        if (drawXOff == 0){  // if drawing a shadow, we don't need to add the eyes
            if (_blinkTimer &lt; 147){  // eyes open
                draw_sprite_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), x - 800*sign(x - 400), y, image_xscale, image_yscale, 0, c_white, 1);
            }else if (_blinkTimer &gt;= 151 &amp;&amp; _blinkTimer &lt; 155){  // eyes shut
                draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, 0, _eyeSprW, 2, (x - 800*sign(x - 400)) - (_eyeWidth/2), y - _eyeHeight + 3, image_xscale, image_yscale, c_white, 1);
                draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, _eyeSprH-2, _eyeSprW, 2, x - 800*sign(x - 400) - (_eyeWidth/2), y - _eyeHeight + 3 + 2, image_xscale, image_yscale, c_white, 1);
            }else{  // in-between
                draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, 0, _eyeSprW, 2, x - 800*sign(x - 400) - (_eyeWidth/2), y - _eyeHeight + 2, image_xscale, image_yscale, c_white, 1);
                draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, floor((_eyeSprH-2)/2), _eyeSprW, 2, x - 800*sign(x - 400) - (_eyeWidth/2), y - _eyeHeight + 2 + 2, image_xscale, image_yscale, c_white, 1);
                draw_sprite_part_ext(sprGeezerPacPhantomEyes, color*4 + (t_dir div 90), 0, _eyeSprH-2, _eyeSprW, 2, x - 800*sign(x - 400) - (_eyeWidth/2), y - _eyeHeight + 2 + 2 + 2, image_xscale, image_yscale, c_white, 1);
            }
        }
    }
/*}else{
    if (eaten){
        draw_sprite(sprGeezerPacEyes, (round(direction/90) mod 4), x, y)
        if (warping) draw_sprite(sprGeezerPacEyes, (round(direction/90) mod 4), x - 800*sign(x - 400), y)
    }
    else{
        if (frightTimer &gt; 60 || (frightTimer mod 24 &gt;= 12)){
            draw_sprite(sprGeezerPacGhostFrightened, ((global.count mod 20) div 10), x, y)
            if (warping) draw_sprite(sprGeezerPacGhostFrightened, ((global.count mod 20) div 10), x - 800*sign(x - 400), y)
        }else{
            draw_sprite(sprGeezerPacGhostFrightened, 2 + ((global.count mod 20) div 10), x, y)
            if (warping) draw_sprite(sprGeezerPacGhostFrightened, 2 + ((global.count mod 20) div 10), x - 800*sign(x - 400), y)
        }
    }
}*/

if ((showLetter || chase) &amp;&amp; global.colorBlind){
    draw_set_font(fDefault18);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var _letter = "", _color = c_white;
    switch(color){
        case 0:
            _letter = "R";
            //_color = make_color_rgb(187, 0, 0);
            break;
        case 1:
            _letter = "P";
            //_color = make_color_rgb(197, 0, 206);
            break;
        case 2:
            _letter = "B"; //it's really "Cyan" but who cares?
            //_color = make_color_rgb(0, 172, 172);
            break;
        case 3:
            _letter = "O";
            //_color = make_color_rgb(167, 105, 0);
            break;
    }
    //_color use removed
    if (is_string(_letter)){
        draw_set_color(c_white);  // (_color);  // removed because it reduced visiblity, which is bad for an accessibility feature intended for color blind people
        draw_text_outline(x+2, y+2, _letter, 2, c_black, 8);
        if (warping){
            draw_text_outline(x - 800*sign(x - 400)  +2, y+3, _letter, 2, c_black, 8);
        }
        draw_set_color(c_white);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
