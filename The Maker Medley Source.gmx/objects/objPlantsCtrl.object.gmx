<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprTriggerMask</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-15</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>introTimer = -30;
currency = 20;  // 20 coins as initial amount
coinTimer = 250;  // after planting first plant
coinsDropped = 0; // from ceiling

// prevent loud overlapping sounds
sfxDelay[0] = 3; 
sfxDelay[1] = 16;
cannonSfxCounter = sfxDelay[1];
spikeSfxCounter = sfxDelay[1];
hitSfxCounter = sfxDelay[1];

currencyColor = make_color_rgb(108, 59, 79);
upgradePacketColor = make_color_rgb(154, 44, 189);

columns = 9; rows = 6;
for(var i=(columns-1);i&gt;=0;i--){
    for(var j=(rows-1);j&gt;=0;j--){
        plantGrid[i, j] = noone;
    }
}

dragXOff = 0;
dragYOff = 0;
selecting = -1;
clicking = -1;
hotkeyPressed = -1;  // 0-&gt;[(totalPlants-1)] are for plants; [deleteInd)] is for removing (backspace key)

roundState = -1;  //-1 = intro; 0 = pre-first plant;  1 = active;  2 = wait for all enemies to die; 3 = ending
numberPlanted = 0;  // we need to set the psuedo RNG values based on how many plants the player has placed
deathTimer = 0;
deathGameOverDelay = 30;
deathEffect = false;
plantsCount = 0;
elapsedTime = 0;
elapsedTimeAlpha = 0;

// Explanation:  This system looks complicated, but it really isn't
// The player influences the psuedoRNGVal by *where* they plant their first plant, and *when* they plant their (6*n + 2)th plant
// visual_psuedoRNGVal is only used for visual effects, such as naturally-spawning coins and plant animation speeds. This is influenced by every plant the player places
// If the player plants the first plant in the same location, and plants the (6*n + 2)th plant between the same psuedoRNG calls, they will recieve the same enemy spawns
psuedoRNGVal = 0;  // used for enemy positions, types, delays, etc.
visual_psuedoRNGVal = 0;  // used for plant animation speeds and random coin spawning

totalPlants = 6;
totalIcons = (totalPlants+1);
deleteOffset = 1;
deleteInd = ((totalPlants-1)  + deleteOffset);  // (totalPlants-1) =&gt; highest plant index

for(var i=(totalPlants-1);i&gt;=0;i--){
    plantObj[i] = -1;
    plantCost[i] = -1;
    cooldown[i] = -1;
    cooldownMax[i] = 300;
}

iconAngFluct = 20;
for(var i=(totalIcons-1);i&gt;=0;i--){
    iconSpr[i] = -1;
    iconSubimg[i] = 0;
    iconAngSine[i] = 0;
    iconScale[i] = 1;
    iconScaleInc[i] = 0;
    
    iconScaleMult[i] = 1;
    gridScaleMult[i] = 1;
}

//constants
destroyIconX = 512;
destroyIconY = 32;
currencyIconX = 704;
speedButtonX = 592;
meterRight = 764;  // progress meter
meterWidth = 144;
meterY = 590;

//elapsedTimeX = meterRight - 0.75*meterWidth;
elapsedTimeRight = 748;
elapsedTimeY = meterY - 24;

//intro
guiHeight = -112;
skipTextAlpha = 0;  // intro "Press S..."

// plant/enemy crushing
crushSurf = -4;
crushSurfDim = 128;

//icons + small effects
smallSurf = -4;
smallSurfDim = 96;  // spring needs 96 width
progressMeterAlpha = 0;
// for the activator color cycling
activatorsPlaced = 0;
activatorPrev = 0;
activatorTransition = 0;

// speed change
speedUp = false;
speedUpButtonInd = 0;
speedChangeDelay = -1;

//Wave spawning
spawnArray = 0;  // spawn options
spawnPositionsTracked = 4;  // a spawner will not generate on a row that was spawned on by the last [spawnPositionsTracked] enemies
//( when using more than [spawnPositionsTracked] spawners, this is not gauranteed since the delay until spawners activate is (psuedo-)random )
// `spawnPositionsTracked` must be less than the number of rows
for (var i=(spawnPositionsTracked-1); i &gt;= 0; i--){
    spawnRowArray[i] = -1;  // row enemy will spawn on
}
spawnChoices = 0;
spawnMaxDelay = 0;
waveSpawnPoints = 1;  // will increase by 1 every 3 waves
currentWave = 0;
waveTotal = 20;
currentWavePointTotal = 0;  // current wave's total points
currentWavePointSpawned = 0;  // for progress meter; accounts for spawn delay
currentWaveHealth = 0;  // current wave's current health  (using instance variable for debugging purposes)
currentWaveHealthInit = 0;  // current wave's initial health

// Wave timing values
waveTimer = -(10 * 50);  // 14 second delay before first wave
waveStart = -80; // 1.6 second delay for all waves after that
waveHealthThreshold = 0;  // wave health is checked against (initial health * threshold)... 
waveHealthThresholdFast = 0.5;  //...which starts at 0 and increases over 2.5 seconds until it hits `waveHealthThresholdFast`...
waveHealthThresholdMax = 0.65;  //...and then increases over 4 seconds until it hits `waveHealthThresholdMax`
minWaveDelay = 4 * 50;  // 4 second minimum
maxWaveDelay = 24 * 50;    // 24 second maximum
//text animations
hugewaveStart = -180;  // extra time to allow for opening
hugewaveAppearTime = 40;  // from inital appearance to full opacity
hugewaveDisappearTime = 20;  // from full opacity to disappearance
hugewaveSpawnStart = 30;
hugewaveSpawnerDelay = 145;
finalwaveTextLen = 80;
textSnd = -1;

event_user(1);  // Plant + Wave information

/*
// Testing enemies
instance_create(irandom_range(400, 800), irandom_range(224, 480), objPlantsCherry);
(instance_create(irandom_range(400, 800), irandom_range(224, 480), objPlantsCherry)).subtype = 1;
instance_create(irandom_range(400, 800), irandom_range(224, 480), objPlantsDancingCherry);
instance_create(irandom_range(400, 800), irandom_range(224, 480), objPlantsHyperCherry);
instance_create(irandom_range(400, 800), irandom_range(224, 480), objPlantsMiku);
instance_create(irandom_range(400, 800), irandom_range(224, 480), objPlantsGuy);
instance_create(irandom_range(400, 800), irandom_range(224, 480), objPlantsIWBTGSpike);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>surface_free(crushSurf);
surface_free(smallSurf);

audio_stop_sound(sndMakerMenuInvalid);
audio_stop_sound(sndMakerMenuClick);
audio_stop_sound(sndMakerMenuSelect);
audio_stop_sound(sndMakerMenuRelease);

// only needed if we're treating it like music
audio_stop_sound(sndPlantsMiku);
audio_stop_sound(sndPlantsGameOver);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Transition to hub
var _roomTransition;
_roomTransition = instance_create(160, 256, objMakerTeleTransition);
_roomTransition.exitIndex = 0;
_roomTransition.camDir = 0;
_roomTransition.roomTo = rStage03Hub; //prevents C1 Biff-like errors if player restarts
_roomTransition.offset = 8; //between this screen and the last one
_roomTransition.sprite = scrGetScreenSprite();
_roomTransition.save = false;
_roomTransition.exitPartCol = make_color_rgb(206, 95, 91);
room_goto(rStage03Hub);
audio_sound_pitch(audio_play_sound(sndMakerTeleportPersist, 0, 0), PITCH_FLUCT);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Death + Player Input
if (!global.dead){  // everything should freeze when the player death animation is active
    // Check if we died
    if ((roundState &gt;= 0 &amp;&amp; roundState &lt; 3)){  // &amp;&amp; !global.dead
        var _killer = noone;
        with (objPlantsEnemy){
            if (bbox_left &lt; 20 &amp;&amp; !dead){
                if (!global.debugNoDeath){
                    if (!instance_exists(_killer)){
                        _killer = id;
                    }else if (instance_exists(_killer) &amp;&amp; bbox_left &lt; _killer.bbox_left){
                        _killer = id;
                    }
                }else{
                    event_user(2);
                }
                break;
            }
        }
        if (_killer != noone){
            global.dead = true;
            global.death += 1; //increment deaths
            scrSaveGame(false); //save death/time
            
            clicking = -1;
            hotkeyPressed = -1;
            
            with (_killer){
                killing = true;
                killingState = 0;
                attacking = noone;
                
                event_user(6);  // actions when (killingState == 0)
            }
            instance_create(-48, 352, objPlantsPlayerCage);
            
            with (objPlantsEnemy){
                if (!killing){
                    frozen = true;
                    speed = 0;
                    image_speed = 0;
                }
            }
            with (objWorld){
                playMusic = false;
            }
            with (objPlantsEnemySpawner){instance_destroy();}
            with (all){
                if (!persistent &amp;&amp; !object_is_ancestor(object_index, objPlantsEnemy)){
                    frozen = true;
                    speed = 0;
                    gravity = 0;
                    image_speed = 0;
                }
            }
            with (objExpandFade){
                angInc = 0;
                alphaInc = 0;
            }
            //slow down frame rate if sped up
            if (speedUp){
                speedUp = false;
                room_speed = 50;
                audio_stop_sound(sndPlantsSpeedup);
                audio_play_sound(sndPlantsSlowdown, 0, 0);
            }
            
            audio_stop_sound(sndPlantsMiku);
            audio_stop_sound(textSnd);
            
            audio_sound_gain(global.currentMusic, 0, 200);
            audio_play_sound(sndPlantsLose, 0, 0);
        }
    }
    
    // Planting (incl. Hotkeys)
    if ((roundState &gt;= 0 &amp;&amp; roundState &lt; 3)){  // &amp;&amp; !global.dead
        if (roundState &gt;= 1){
            for(var i=0; i&lt;=(totalPlants-1); i++){
                if (cooldown[i] &gt; 0){
                    cooldown[i] --;
                }
            }
        }
        
        // [HOTKEY SYSTEM] \\
        var _hotkeyPrev = hotkeyPressed;
        
        if (clicking == -1 &amp;&amp; hotkeyPressed == -1){  // Check if the player pressed a hotkey (and is not currently dragging something)
            for (var i=0; i&lt;min(totalPlants, 9); i++){  // best code  vvvvvv
                if (keyboard_check_pressed(ord(string(i+1))) &amp;&amp; (cooldown[i] &lt;= 0 &amp;&amp; currency &gt;= plantCost[i])){
                    hotkeyPressed = i;
                }
            }
            if (hotkeyPressed == -1){  // not pressing 1-5
                if (keyboard_check_pressed(vk_backspace)){
                    hotkeyPressed = deleteInd;
                }
            }
            
            if (hotkeyPressed != -1){  // dragging something
                dragXOff = 0;
                dragYOff = 0;
                audio_stop_sound(sndPlantsClick);
                audio_play_sound(sndPlantsClick, 0, 0);
            }
        }
        
        if (_hotkeyPrev != -1){  // Using a hotkey
            // Setting `hotkeyPressed` to -1 signals that we released the hotkey that is stored in `_hotkeyPrev`
            if (hotkeyPressed == deleteInd){  // backspace
                if (!keyboard_check(vk_backspace)){
                    hotkeyPressed = -1;
                }
            }else if (hotkeyPressed &gt;= 0 &amp;&amp; hotkeyPressed &lt; totalPlants){
                if (!keyboard_check(ord(string(hotkeyPressed+1)))){
                    hotkeyPressed = -1;
                }
            }
        }
        // [END HOTKEY SYSTEM] \\
        
        var _selectingPrev = selecting;
        selecting = -1;
        if (hotkeyPressed == -1){
            // Mouse checks
            // Plants
            for(var i=(totalPlants-1); i&gt;=0; i--){
                mask_index = iconSpr[i];
                x = view_xview + (80*i + 48);
                y = (guiHeight + 48);
                
                image_xscale = iconScale[i]*iconScaleMult[i];
                image_yscale = image_xscale;
                //image_angle = iconAngFluct*sin(iconAngSine[i]);
                
                if (collision_point(mouse_x, mouse_y, id, true, false) == id){
                    if ((cooldown[i] &lt;= 0 &amp;&amp; currency &gt;= plantCost[i]) || global.debugNoDeath){
                        if (_selectingPrev != i){
                            audio_stop_sound(sndMakerMenuSelect);
                            audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
                        }
                        selecting = i;
                    }else if (mouse_check_button_pressed(mb_left)){
                        audio_stop_sound(sndMakerMenuInvalid);
                        audio_play_sound_nogroup(sndMakerMenuInvalid, 0, 0);
                    }
                }
            }
            
            // "Delete" icon
            mask_index = iconSpr[deleteInd];
            x = view_xview + destroyIconX;
            y = (guiHeight + destroyIconY);
            
            image_xscale = iconScale[deleteInd]*iconScaleMult[deleteInd];
            image_yscale = image_xscale;
            //image_angle = iconAngFluct*sin(iconAngSine[deleteInd]);  // causes some glitches
            
            // Collision check
            if (selecting == -1){
                if (collision_point(mouse_x, mouse_y, id, true, false) == id){
                    if (_selectingPrev != deleteInd){
                        audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
                    }
                    selecting = deleteInd;
                    if (mouse_check_button_pressed(mb_left)){
                        audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);
                        clicking = deleteInd;
                        dragXOff = (x - mouse_x);
                        dragYOff = (y - mouse_y);
                        iconScaleInc[deleteInd] = 1;
                    }
                }
            }
            
            // Reset position values
            mask_index = -1;
            x = 0;
            y = 0;
            
            image_xscale = 1;
            image_yscale = 1;
            //image_angle = 0;
            
            if (mouse_check_button_pressed(mb_left) &amp;&amp; selecting &gt;= 0 &amp;&amp; selecting &lt; totalIcons){
                if ((_hotkeyPrev == -1 &amp;&amp; hotkeyPressed == -1 &amp;&amp; clicking == -1) &amp;&amp; mouse_y &lt; 80+guiHeight){
                    audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);
                    clicking = selecting;
                    iconScaleInc[selecting] = 1;
                    dragXOff = (80*selecting + 48) - mouse_x;
                    dragYOff = (guiHeight + 48) - mouse_y;
                }else{
                    audio_stop_sound(sndMakerMenuInvalid);
                    audio_play_sound_nogroup(sndMakerMenuInvalid, 0, 0);
                }
            }
            
            var _input = -1;
            if (!mouse_check_button(mb_left) &amp;&amp; clicking != -1){  // dragged and released  (takes priority over hotkey release)
                _input = clicking;
                clicking = -1;
                audio_play_sound_nogroup(sndMakerMenuRelease, 0, 0);
            }else if (_hotkeyPrev != -1 &amp;&amp; hotkeyPressed == -1){  // hotkey release
                _input = _hotkeyPrev;
                audio_play_sound_nogroup(sndMakerMenuRelease, 0, 0);
            }
            
            if (_input != -1 &amp;&amp; mouse_x &gt;= 96 &amp;&amp; mouse_y &gt;= 160){  // released mouse button when dragging something,  OR   released a hotkey
                var _gridX, _gridY;
                _gridX = (mouse_x - 96) div 64;
                _gridY = (mouse_y - 160) div 64;
                
                if ((_gridX &gt;= 0 &amp;&amp; _gridX &lt; columns &amp;&amp; _gridY &gt;= 0 &amp;&amp; _gridY &lt; rows) &amp;&amp; plantGrid[_gridX, _gridY] != -1){  // -1 = crater
                    if (_input &gt;= 0 &amp;&amp; _input &lt; totalPlants){
                        var _planting = plantObj[_input];
                        var _occupying = plantGrid[_gridX, _gridY];
                        if (instance_exists(_occupying)){ //failsafe if a plant disappears w/o it registering in the plant array
                            plantGrid[_gridX, _gridY] = noone;
                            with (objPlantsPlant){
                                if (!dead &amp;&amp; column == _gridX &amp;&amp; row == _gridY){
                                    other.plantGrid[column, row] = id;
                                }
                            }
                        }
                        if (((!scrPlantsIsUpgrade(_planting) &amp;&amp; (!instance_exists(_occupying) || (!scrPlantsStationary(_planting) &amp;&amp; !scrPlantsDetectable(_occupying)))) || (scrPlantsIsUpgrade(_planting) &amp;&amp; scrPlantsUpgradeable(_occupying, _planting))) &amp;&amp; (collision_circle(_gridX*64 + 128, _gridY*64 + 192, 28, objPlantsShuriken, false, true) == noone || scrPlantsInvincible(_planting)) &amp;&amp; ((cooldown[_input] &lt;= 0 &amp;&amp; currency &gt;= plantCost[_input]) || global.debugNoDeath)){
                            if (scrPlantsIsUpgrade(_planting)){ // the cannon -&gt; spike upgrade
                                _occupying.growing = false;
                                _occupying.convertToSpike = true;
                            }
                            
                            visual_psuedoRNGVal = scrPlantsPsuedoRNG(visual_psuedoRNGVal, 4.39);
                            var _inst = scrPlantsSpawnPlant(_gridX, _gridY, _planting);
                            currency -= plantCost[_input];
                            cooldown[_input] = cooldownMax[_input];
                            
                            if (numberPlanted == 0){
                                //roundState = 1;  // game will no longer wait for layer to put down first plant before starting the round
                                psuedoRNGVal = ((_gridX * 3.74) + (_gridY * 4.63) + 1) * 17.9;
                                visual_psuedoRNGVal = psuedoRNGVal * 2.3;
                            }
                            
                            numberPlanted ++;
                            var _snd = audio_play_sound(sndPlantsPlace, 0, 0);
                            audio_sound_pitch(_snd, PITCH_FLUCT);
                            
                            
                            // Psuedo RNG reshuffling  (this is how the player's actions can influence RNG)
                            if ((numberPlanted mod 6) == 2){  //2, 8, 14...
                                psuedoRNGVal = scrPlantsPsuedoRNG(psuedoRNGVal, 10.74);
                            }
                            
                            //show_debug_message("Planted plant " + string(numberPlanted) + ";  psuedoRNGVal increased to " + string(psuedoRNGVal));
                        }else{
                            audio_stop_sound(sndMakerMenuInvalid);
                            audio_play_sound_nogroup(sndMakerMenuInvalid, 0, 0);
                        }
                    }else if (_input == deleteInd){
                        if (instance_exists(plantGrid[_gridX, _gridY])){
                            with (plantGrid[_gridX, _gridY]){
                                hp = 0;
                                event_user(2);
                                instance_create(x, y, objPlantsDestroyed);
                            }
                        }else{
                            audio_stop_sound(sndMakerMenuInvalid);
                            audio_play_sound_nogroup(sndMakerMenuInvalid, 0, 0); //tried to plant outside the grid
                        }
                    }
                }else{
                    audio_stop_sound(sndMakerMenuInvalid);
                    audio_play_sound_nogroup(sndMakerMenuInvalid, 0, 0); //tried to plant outside the grid
                }
            }
        }
    }
    
    // Plant icon management
    var _multiplier = (delta_time/20000);
    var _angIncAmt = (pi/10) * _multiplier;
    for (var i=0; i&lt;totalIcons; i++){
        if (iconScale[i] != 1 || iconScaleInc[i] == 1){
            if (iconScaleInc[i] == 1){
                iconScale[i] = min(iconScale[i] + 0.1*_multiplier, 1.4);
                if (iconScale[i] &gt;= 1.4){
                    iconScaleInc[i] = 0;
                }
            }else{
                iconScale[i] = max(iconScale[i] - 0.04*_multiplier, 1);
            }
        }
        if (selecting == i &amp;&amp; (clicking == -1 &amp;&amp; hotkeyPressed == -1)){
            iconAngSine[i] += _angIncAmt;
        }else{
            if (iconAngSine[i] != 0){
                var _check = ((iconAngSine[i]) mod pi);
                if (_check &lt; _angIncAmt || _check &gt;= (pi-_angIncAmt)){
                    iconAngSine[i] = 0;
                }else{
                    iconAngSine[i] += _angIncAmt;
                }
            }
        }
    }
    
    // Clicking on coins
    if (mouse_check_button_pressed(mb_left) &amp;&amp; !(mouse_y &lt; (96+guiHeight) &amp;&amp; (mouse_x &lt;= 416 || mouse_x == median(448, mouse_x, 544)))){  // &amp;&amp; !global.dead
        with (objMouseClickCheck){
            with (instance_place(x, y, objPlantsCoin)){ //only select one
                with (instance_create(x, y, objPlantsCoinCollected)){
                    image_index = other.image_index;
                    brightness = other.brightness;
                    yBase = other.yBase;
                    
                    scaleInit = other.image_xscale;
                    image_xscale = scaleInit;
                    image_yscale = image_xscale;
                }
                instance_destroy();
            }
        }
    }
    
    if (activatorTransition &gt; 0){
        activatorTransition = max(activatorTransition - 0.0333, 0);
    }
}else{
    if (deathEffect){
        deathTimer += 1;
        if (floor(deathTimer) == deathGameOverDelay){
            if (!global.muteMusic &amp;&amp; global.musicLevel &gt; 0 &amp;&amp; global.volumeLevel &gt; 0){
                var _snd = audio_play_sound(sndPlantsGameOver, 0, 0);
                audio_sound_gain(_snd, 0.8 * global.musicLevel/100 * global.volumeLevel/100, 0);
            }
        }
    }
    
    if (view_xview &gt; -96){
        view_xview = max(view_xview-2, -160);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Passive coin generation
// Set `coinTimer` to a negative value to disable
if (coinTimer &gt;= 0){
    if ((roundState == 1 || roundState == 2) &amp;&amp; !global.dead){
        coinTimer --;
        if (coinTimer &lt;= 0){
            visual_psuedoRNGVal = scrPlantsPsuedoRNG(visual_psuedoRNGVal, 7.97);
            
            with (instance_create(192 + ((floor(visual_psuedoRNGVal) mod 60) div 10)*64, -32, objPlantsCoin)){
                hspeed = 0;
                vspeed = 4;
                brightness = 0;
                yBase = 192 + ((floor(other.visual_psuedoRNGVal*3.93) mod 60) div 10)*64;
            }
            coinsDropped ++;
            coinTimer = min(10.50, 4.25 + (coinsDropped * 0.85)) * 50;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///PvZ2 Speed Up button
if (speedChangeDelay &lt;= 0 &amp;&amp; introTimer &gt;= 150 &amp;&amp; (mouse_x &gt; speedButtonX &amp;&amp; mouse_x &lt; (speedButtonX+64) &amp;&amp; mouse_y &gt;= 16 &amp;&amp; mouse_y &lt;= 80) &amp;&amp; mouse_check_button_pressed(mb_left) &amp;&amp; !global.dead){
    if (roundState &gt;= 1 &amp;&amp; roundState &lt; 3){
        speedUp = !speedUp;
        if (speedUp){
            room_speed = 100;
            audio_stop_sound(sndPlantsSlowdown);
            audio_play_sound(sndPlantsSpeedup, 0, 0);
        }else{
            room_speed = 50;
            audio_stop_sound(sndPlantsSpeedup);
            audio_play_sound(sndPlantsSlowdown, 0, 0);
        }
        if (audio_is_playing(textSnd)){
            audio_sound_pitch(textSnd, room_speed/50);
        }
        
        // change Miku music speed
        with (objPlantsMikuEffectCtrl){
            event_user(2);
        }
    }else{
        audio_play_sound_nogroup(sndMakerMenuInvalid, 0, 0);
    }
}

if (speedUp || (!speedUp &amp;&amp; speedUpButtonInd mod 8 &gt;= 1)){
    speedUpButtonInd += 0.3*(delta_time/20000); //0.3 normally, but if framerate is currently doubled it's 0.15
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Intro and wave management
if (!global.dead){
    if (introTimer &lt; 210){
        introTimer ++;
        if (introTimer == 0){
            audio_play_sound(sndPlantsIntro, 0, 0);
        }
        if (roundState == -1 &amp;&amp; introTimer &gt;= 0 &amp;&amp; introTimer &lt; 150 &amp;&amp; scrButtonCheckPressed(global.skipButton)){
            introTimer = 150;
            audio_stop_sound(sndPlantsIntro);
        }
        if (introTimer &gt;= 150){
            if (roundState == -1){
                roundState = 1;  // don't wait for player to plant first plant
                
                scrIdentAttack(room, 0);  // basically scrIdentRoom();
                with (objWorld){
                    playMusic = true;
                }
            }
            if (introTimer &gt; 150 &amp;&amp; introTimer &lt;= 170){
                guiHeight = -112*(1-sin((introTimer - 150)/20 * pi/2));
            }
        }
    }
    
    if (roundState &gt; 0){
        waveTimer ++;
        
        //Detect if current (previously-spawned) wave is a "Huge Wave"
        var _inFlagWave = false;
        for (var i=0; i&lt;flagCount; i++){
            if (currentWave == flagWave[i]){
                _inFlagWave = true;
                break;
            }
        }
        
        //Wave management
        if (currentWavePointSpawned &gt;= currentWavePointTotal || currentWave &lt; 1){
            if (currentWave &lt; waveTotal){  // waves before final wave
                var _checkAllEnemies = false;
                for (var i=0; i&lt;flagCount; i++){
                    if ((currentWave+1) == flagWave[i]){
                        _checkAllEnemies = true;
                        break;
                    }
                }
                
                if (currentWave == 0){
                    if (waveTimer &gt;= 0){
                        event_user(2);  // start first wave
                        progressMeterAlpha = 1;
                    }else if (waveTimer &gt;= -100){
                        if (waveTimer == -100){audio_play_sound(sndPlantsWave1Warning, 0, 0)}
                        progressMeterAlpha = (waveTimer+100)/100;
                    }
                }else if (waveTimer &gt;= minWaveDelay){  // Attempt to start next wave
                    if ((!_checkAllEnemies &amp;&amp; waveTimer &gt;= maxWaveDelay) || (_checkAllEnemies &amp;&amp; waveTimer &gt;= (1.76*maxWaveDelay))){  // much longer max wave time if checking all enemies before huge wave
                        event_user(2);
                    }else{
                        //calculate wave health
                        if (_checkAllEnemies){
                            currentWaveHealth = scrPlantsWaveHP(-1);
                        }else{
                            currentWaveHealth = scrPlantsWaveHP(currentWave);
                            if (waveTimer &gt; minWaveDelay){
                                var _excess = (waveTimer - minWaveDelay);
                                var _delay1 = 62.5;  // to 0.5
                                var _delay2 = 120;  // to 0.65
                                if (_excess &lt; _delay1){  // 1.25 seconds
                                    waveHealthThreshold = lerp(0, waveHealthThresholdFast, min(_excess/_delay1, 1));
                                }else if (_excess &lt; _delay2){ // 
                                    waveHealthThreshold = lerp(waveHealthThresholdFast, waveHealthThresholdMax, min((_excess-_delay1)/max(_delay2, 1), 1));
                                }else{
                                    waveHealthThreshold = waveHealthThresholdMax;
                                }
                            }
                        }
                        
                        if ((!_checkAllEnemies &amp;&amp; currentWaveHealth &lt;= (currentWaveHealthInit * waveHealthThreshold))  ||  (_checkAllEnemies &amp;&amp; currentWaveHealth &lt;= 0)){
                            var _advance = true;
                            if (_checkAllEnemies){
                                with (objPlantsMikuSpinner){
                                    if (holding){_advance = false; break;}
                                }
                            }
                            
                            if (_advance){
                                event_user(2);
                            }
                        }
                    }
                }
            }else if (roundState == 2){  // wait for all enemies to die
                currentWaveHealth = scrPlantsWaveHP(-1);
                if (currentWaveHealth &lt;= 0){
                    if (!instance_exists(objPlantsEndingGun)){  // should have been dropped by The Guy
                        instance_create(400, -30, objPlantsEndingGun);
                    }
                    with (objPlantsEndingGun){
                        falling = 1;
                    }
                    with (objPlantsCoinBlock){produce = false;}
                    
                    if (global.pvzFastest &lt; 0 || elapsedTime &lt; global.pvzFastest){
                        global.pvzFastest = elapsedTime;
                    }
                    roundState = 3;
                    if (speedUp){
                        speedUp = false;
                        room_speed = 50;
                        if (audio_is_playing(textSnd)){
                            audio_sound_pitch(textSnd, room_speed/50);
                        }
                        with (objPlantsMikuEffectCtrl){
                            if (audio_is_playing(mikuMusic)){
                                audio_sound_pitch(mikuMusic, room_speed/50);
                            }
                        }
                        audio_stop_sound(sndPlantsSpeedup);
                        audio_play_sound(sndPlantsSlowdown, 0, 0);
                    }
                    with (objWorld){
                        alarm[0] = 50;
                        audio_sound_gain(global.currentMusic, 0, 1000);
                    }
                }
            }
        }
        
        //"Huge Wave" text sound effects
        if (_inFlagWave){
            if (waveTimer == (hugewaveStart + hugewaveAppearTime)){
                textSnd = audio_play_sound(sndPlantsHugewave, 0, 0);
                if (audio_is_playing(textSnd)){
                    audio_sound_pitch(textSnd, room_speed/50);
                }
            }else if (currentWave == flagWave[(flagCount-1)]){
                if (waveTimer == hugewaveSpawnStart + hugewaveAppearTime){
                    audio_stop_sound(textSnd);
                    textSnd = audio_play_sound(sndPlantsFinalwave, 0, 0);
                    if (audio_is_playing(textSnd)){
                        audio_sound_pitch(textSnd, room_speed/50);
                    }
                }else if (waveTimer == 80){
                    audio_play_sound(sndPlantsWaveSiren, 0, 0);  // does not get sped up
                }
            }
        }
    }
    plantsCount ++; //like global.count
    
    if (roundState &gt; 0 &amp;&amp; roundState &lt; 3){
        elapsedTime ++;  // speeding up the game will not help here. This is a test of stategy, not reflexes
        if (elapsedTimeAlpha &lt; 1){
            elapsedTimeAlpha = min(elapsedTimeAlpha + 0.05, 1);
        }
    }
    
    if (cannonSfxCounter &lt; sfxDelay[1]){
        cannonSfxCounter ++;
    }
    if (spikeSfxCounter &lt; sfxDelay[1]){
        spikeSfxCounter ++;
    }
    if (hitSfxCounter &lt; sfxDelay[1]){
        hitSfxCounter ++;
    }
}

if (introTimer &gt;= 0 &amp;&amp; introTimer &lt; 150){
    skipTextAlpha = min(skipTextAlpha+0.02, 1);
}else if (skipTextAlpha &gt; 0){
    skipTextAlpha = max(skipTextAlpha-0.04, 0);
}

if (speedChangeDelay &gt; 0){
    speedChangeDelay --;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Play cannon/spike shoot sound
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Frontmost drawing
var _planting;
_planting = clicking;
if (_planting == -1){
    _planting = hotkeyPressed;
}
// Mouse placement dragging
if (!global.dead){
    if (_planting &gt;= 0 &amp;&amp; _planting &lt; totalIcons){
        //draw_sprite_ext(iconSpr[_planting], 0, mouse_x+dragXOff*iconScale[_planting], mouse_y+dragYOff*iconScale[_planting], iconScale[_planting]*iconScaleMult[_planting], iconScale[_planting]*iconScaleMult[_planting], 0, c_white, 1);
        draw_sprite_ext(iconSpr[_planting], iconSubimg[_planting], mouse_x, mouse_y, iconScale[_planting]*iconScaleMult[_planting], iconScale[_planting]*iconScaleMult[_planting], 0, c_white, 1);
    }
}

if (!global.screenshotMode){
    //Progress Meter
    if (progressMeterAlpha &gt; 0){
        var _spawnRatio = (currentWavePointSpawned/max(currentWavePointTotal, 1));
        if (waveTimer &lt;= 0){_spawnRatio = 0;}
        var _progress = clamp((currentWave - clamp(1-_spawnRatio, 0, 1))/waveTotal,  0,  1);
        var _usingSurf = false;
        var _drawX = 0;
        if (progressMeterAlpha &lt; 1){
            if (!surface_exists(global.sharedSurf)){
                global.sharedSurf = surface_create(800, 608);
            }
            if (surface_exists(global.sharedSurf)){
                surface_set_target(global.sharedSurf);
                draw_clear_alpha(c_black, 0);
                _usingSurf = true;
            }
        }
        if (!_usingSurf){
            _drawX = min(view_xview, 0);
        }
        
        //draw meter
        draw_sprite(sprPlantsProgressMeter, 0, _drawX + (meterRight+6), meterY);
        draw_sprite_ext(sprPlantsProgressBar, 0, _drawX + meterRight, meterY, (meterWidth * _progress), 1, 0, c_white, 1);
        var _flagX, _flagHeight;
        for (var i=0; i&lt;flagCount; i++){
            _flagX = (_drawX + meterRight - (meterWidth * (flagWave[i]/waveTotal)));
            _flagHeight = 0;
            if (currentWave &lt; flagWave[i]){
                _flagHeight = 0;
            }else if (currentWave &gt; flagWave[i]){
                _flagHeight = 1;
            }else{  // in wave
                var _startTime = 24, _endTime = 96;
                if (waveTimer &lt; _startTime){
                    _flagHeight = 0;
                }else if (waveTimer &gt;= _endTime){
                    _flagHeight = 1;
                }else if (waveTimer &gt;= _startTime &amp;&amp; waveTimer &lt; _endTime){
                    _flagHeight = (waveTimer - _startTime) / (_endTime - _startTime);
                }
            }
            draw_sprite(sprPlantsProgressFlagpole, 0, _flagX, meterY);
            draw_sprite(sprPlantsProgressFlag, 0, _flagX, meterY - 12*_flagHeight);
        }
        draw_sprite(sprCherry, 0, _drawX  +  (meterRight-1) - (meterWidth * _progress), (meterY-2));
        draw_sprite(sprPlantsProgressSign, 0, _drawX  +  (meterRight - meterWidth/2), (meterY+6));
        
        
        if (_usingSurf){
            surface_reset_target();
            _usingSurf = false;
            
            if (surface_exists(global.sharedSurf)){
                draw_surface_ext(global.sharedSurf, min(view_xview, 0), 0, 1, 1, 0, c_white, progressMeterAlpha);
            }
        }
    }
    
    // Big GUI text
    if (introTimer &gt;= 0 &amp;&amp; introTimer &lt; 210){
        //Ready, Set, PLACE
        var _readyEnd = 30;
        var _setEnd = 60;
        var _placeFall = 144;
        var _textSizeInc = 0.15;
        draw_set_font(fStageClear);
        draw_set_halign(fa_center);
        draw_set_valign(fa_middle);
        draw_set_color(c_blue);
        if (introTimer &lt;= _placeFall){
            if (introTimer &lt; _readyEnd){
                draw_text_transformed_outline(400, 304, "Ready", 5, c_black, 16, 0.7 + _textSizeInc * (introTimer/_readyEnd), 0.7 + _textSizeInc * (introTimer/_readyEnd), 0);
            }else if (introTimer &lt; _setEnd){
                draw_text_transformed_outline(400, 304, "Set", 5, c_black, 16, 0.7 + _textSizeInc * (introTimer - _readyEnd)/_readyEnd, 0.7 + _textSizeInc * (introTimer - _readyEnd)/_readyEnd, 0);
            }else{
                draw_text_transformed_outline(400, 304, "PLACE", 5, c_black, 16, 1.2, 1.2, 0);
            }
        }else if (introTimer &lt;= 210){
            draw_text_transformed_outline(400, 304 + (introTimer-_placeFall)*min(17, 0.18*(introTimer-144)), "PLACE", 5, c_black, 16, 1.2, 1.2, 0);
        }
        draw_set_color(c_white);
    }else if (flagCount &gt; 0){
        if (waveTimer &lt; 0){
            var _inFlagWave = false;
            for (var i=0; i&lt;flagCount; i++){
                if (currentWave == flagWave[i]){
                    _inFlagWave = true;
                    break;
                }
            }
            
            if (_inFlagWave){  // "A HUGE WAVE..."
                var _textAppearanceTime = hugewaveAppearTime;
                var _textDisappearanceTime = hugewaveDisappearTime;
                if (waveTimer &gt; hugewaveStart &amp;&amp; waveTimer &lt; 0){
                    var _textScale = 1, _alpha = 1, _input = 1;
                    if (waveTimer &lt; (hugewaveStart + _textAppearanceTime)){
                        _input = (waveTimer - hugewaveStart)/_textAppearanceTime;
                    }else if (waveTimer &gt; (0-_textDisappearanceTime)){
                        _input = abs(waveTimer)/_textDisappearanceTime;
                    }
                    
                    if (_input != 1){  // avoid unnecessary calculations
                        _alpha = min(power(2, (2.4 - 1)) * power(_input, 4), 1);
                    }
                    _textScale += 3*(1-_alpha);
                    
                    draw_sprite_ext(sprPlantsHugeWave, 0, view_xview + 400, view_yview + 304, _textScale, _textScale, 0, c_white, _alpha);
                }
            }
        }else if (currentWave == flagWave[(flagCount-1)] &amp;&amp; waveTimer &gt; hugewaveSpawnStart &amp;&amp; waveTimer &lt;= hugewaveSpawnStart + finalwaveTextLen){  // "FINAL WAVE!" text 
            var _textAppearanceTime = hugewaveAppearTime;
            var _textDisappearanceTime = hugewaveDisappearTime;
            var _textScale = 1, _alpha = 1, _input = 1;
            
            if (waveTimer &lt; (hugewaveSpawnStart + _textAppearanceTime)){
                _input = (waveTimer - hugewaveSpawnStart)/_textAppearanceTime;
            }else if (waveTimer &gt; (hugewaveSpawnStart + (finalwaveTextLen-_textDisappearanceTime))){
                _input = 1 - (((waveTimer - hugewaveSpawnStart) - (finalwaveTextLen-_textDisappearanceTime))/_textDisappearanceTime);
            }
            
            if (_input != 1){  // avoid unnecessary calculations
                _alpha = min(power(2, (2.4 - 1)) * power(_input, 4), 1);
            }
            _textScale += 1.5*(1-_alpha);
            
            draw_sprite_ext(sprPlantsFinalWave, 0, view_xview + 400, view_yview + 304, _textScale, _textScale, 0, c_white, _alpha);
        }
    }
    
    
    //Total Time
    if (elapsedTimeAlpha &gt; 0){
        draw_set_color(c_white);
        draw_set_font(fAttackTimer);
        
        if (!surface_exists(global.sharedSurf)){
            global.sharedSurf = surface_create(800, 608);
        }
        if (surface_exists(global.sharedSurf)){
            surface_set_target(global.sharedSurf);
            draw_clear_alpha(c_black, 0);
            
            draw_set_valign(fa_bottom);
            scrDrawTimer(elapsedTimeRight, elapsedTimeY, elapsedTime, fa_right, true, 2);
            surface_reset_target();
            
            var _usingSurf2 = false;
            var _drawX = 0;
            
            if (elapsedTimeAlpha &lt; 1){
                if (!surface_exists(global.sharedSurf2)){
                    global.sharedSurf2 = surface_create(800, 608);
                }
                if (surface_exists(global.sharedSurf2)){
                    surface_set_target(global.sharedSurf2);
                    draw_clear_alpha(c_black, 0);
                    _usingSurf2 = true;
                }
            }
            
            if (!_usingSurf2){
                _drawX = min(view_xview, 0);
            }
            
            //draw text
            var _outWidth = 3;
            var _prec = 16;
            var _angInc = 360/_prec;
            for (var i=0; i&lt;_prec; i++){
                draw_surface_ext(global.sharedSurf, _drawX + _outWidth*dcos(_angInc*i), _outWidth*(-dsin(_angInc*i)), 1, 1, 0, c_black, 1);
            }
            draw_surface_ext(global.sharedSurf, _drawX, 0, 1, 1, 0, c_white, 1);
            
            
            if (_usingSurf2){
                surface_reset_target();
                _usingSurf2 = false;
                
                if (surface_exists(global.sharedSurf2)){
                    draw_surface_ext(global.sharedSurf2, min(view_xview, 0), 0, 1, 1, 0, c_white, elapsedTimeAlpha);
                }
            }
        }
    }
    
    /*
    // Code used to generate text sprites
    draw_set_font(fFlappyCounter);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    if (!keyboard_check(vk_space)){
        draw_set_color(c_blue);
        draw_text_transformed_outline(400, 128, "A HUGE WAVE IS APPROACHING!", 4, c_black, 8, 0.6, 0.6, 0);
    }else{
        draw_set_color(c_red);  // 96 size font
        draw_text_transformed_outline(400, 128, "FINAL WAVE!", 4, c_black, 8, 0.6, 0.6, 0);
    }
    */
    
    // Skip message
    if (skipTextAlpha &gt; 0){
        var _usingSurf = false;
        if (skipTextAlpha &lt; 1){
            if (!surface_exists(global.sharedSurf)){
                global.sharedSurf = surface_create(800, 608);
            }
            
            if (surface_exists(global.sharedSurf)){
                surface_set_target(global.sharedSurf);
                draw_clear_alpha(c_black, 0);
                _usingSurf = true;
            }
        }
        
        draw_set_font(fFlappyCounter);
        draw_set_halign(fa_right);
        draw_set_valign(fa_bottom);
        draw_set_color(c_white);
        
        var _buttonStr = scrGetKeybind(global.skipButton[global.controllerMode], 'the "Skip" button');
        if (_buttonStr != 'the "Skip" button'){
            _buttonStr = '"' + _buttonStr + '"';
        }
        draw_text_transformed_outline(752, 560, "Press " + _buttonStr + " to skip intro", 3, c_black, 24, 0.5, 0.5, 0);
        
        if (_usingSurf){
            surface_reset_target();
            _usingSurf = false;
            if (surface_exists(global.sharedSurf)){
                draw_surface_ext(global.sharedSurf, 0, 0, 1, 1, 0, c_white, skipTextAlpha);
            }
        }
    }
}

// GAME OVER
if (deathEffect &amp;&amp; deathTimer &gt; deathGameOverDelay){
    draw_set_alpha(min((deathTimer-deathGameOverDelay)/40, 1) * 0.4);
    draw_set_color(c_black);
    draw_rectangle(view_xview - 0.5, view_yview - 0.5, view_xview + 799.5, view_yview + 607.5, false);
    draw_set_color(c_white);
    draw_set_alpha(1);
    
    draw_sprite_ext(sprGameOver, 0, min(view_xview, 0) + 400, view_yview + 304, min((deathTimer-deathGameOverDelay)/40, 1), min((deathTimer-deathGameOverDelay)/40, 1), 0, c_white, 1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Main drawing

//Grid Placement preview
var _planting;
_planting = clicking;
if (_planting == -1){
    _planting = hotkeyPressed;
}
if (!global.dead){
    if (_planting &gt;= 0 &amp;&amp; _planting &lt; totalIcons &amp;&amp; mouse_x &gt;= 96 &amp;&amp; mouse_x &lt; 672 &amp;&amp; mouse_y &gt;= 160 &amp;&amp; mouse_y &lt;= 544){
        var _gridX, _gridY;
        _gridX = (mouse_x - 96) div 64;
        _gridY = (mouse_y - 160) div 64;
        if (_gridX &gt;= 0 &amp;&amp; _gridX &lt; columns &amp;&amp; _gridY &gt;= 0 &amp;&amp; _gridY &lt; rows){
            var _slotOccupied = (plantGrid[_gridX, _gridY] == -1 || (instance_exists(plantGrid[_gridX, _gridY]) &amp;&amp; !(plantGrid[_gridX, _gridY]).dead));
            if (!_slotOccupied || _planting == deleteInd){  // -1 = crater
                var _iconAlpha = 0.5;
                if (_planting == deleteInd &amp;&amp; _slotOccupied &amp;&amp; plantGrid[_gridX, _gridY] != -1){
                    _iconAlpha = 1;
                }
                
                draw_sprite_ext(iconSpr[_planting], iconSubimg[_planting], 96 + (_gridX + 0.5)*64, 160 + (_gridY + 0.5)*64, gridScaleMult[_planting], gridScaleMult[_planting], 0, c_white, _iconAlpha);
            }
        }
    }
}

// Top Menu: 
draw_set_font(fDefault12);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);
//Plants
for(var i=0;i&lt;totalPlants;i++){
    draw_sprite(sprPlantsPacket, 0, min(view_xview, 0) + 80*i, guiHeight);
}
//Destroy icon
draw_sprite(sprPlantsPacket, 2, min(view_xview, 0) + (destroyIconX-32), guiHeight);
//Currency
draw_sprite(sprPlantsPacket, 0, min(view_xview, 0) + currencyIconX, guiHeight);

//plant sprites + hotkey binds
var _blend = c_white;
if (!surface_exists(smallSurf)){
    smallSurf = surface_create(smallSurfDim, smallSurfDim);
}
for(var i=0; i&lt;totalPlants; i++){
    //draw_sprite(sprPlantsHotkeySign, 0, min(view_xview, 0) + 80*i + 24, guiHeight);
    draw_text_outline(min(view_xview, 0) + 80*i + 48  + 1, guiHeight  + 10, string(i+1), 1, c_black, 4);
    
    if (surface_exists(smallSurf)){
        surface_set_target(smallSurf);  // used to cut off parts of the icon that go over the border
        draw_clear_alpha(c_black, 0);
        
        if (i == clicking || i == hotkeyPressed){
            _blend = c_ltgray;
        }else{
            _blend = c_white;
        }
        draw_sprite_ext(iconSpr[i], iconSubimg[i], 32, 32, iconScale[i]*iconScaleMult[i], iconScale[i]*iconScaleMult[i], iconAngFluct*sin(iconAngSine[i]), _blend, 1);
        
        if (iconSpr[i] == sprMakerActivator &amp;&amp; activatorTransition &gt; 0){
            draw_set_colour_write_enable(1, 1, 1, 0);
            draw_sprite_ext(iconSpr[i], activatorPrev, 32, 32, iconScale[i]*iconScaleMult[i], iconScale[i]*iconScaleMult[i], iconAngFluct*sin(iconAngSine[i]), c_ltgray, activatorTransition);
            draw_set_colour_write_enable(1, 1, 1, 1);
        }
        
        surface_reset_target();
        
        if (surface_exists(smallSurf)){
            draw_surface_part(smallSurf, 0, 0, 64, 64, min(view_xview, 0) + 80*i + 16, guiHeight + 16);
        }
        
        //selection corners
        if (i == clicking || i == hotkeyPressed){
            var _centerX = min(view_xview, 0) + (80*i + 48);
            var _middleY = (guiHeight + 48);
            var _cornerDist = 28 + abs(4 - (((plantsCount mod 40) + 4) div 5));  // 28-32
            draw_sprite_ext(sprPlantsSelected, 0, _centerX - _cornerDist, _middleY - _cornerDist, 2, 2, 0, c_white, 1);
            draw_sprite_ext(sprPlantsSelected, 0, _centerX + _cornerDist, _middleY - _cornerDist, -2, 2, 0, c_white, 1);
            draw_sprite_ext(sprPlantsSelected, 0, _centerX - _cornerDist, _middleY + _cornerDist, 2, -2, 0, c_white, 1);
            draw_sprite_ext(sprPlantsSelected, 0, _centerX + _cornerDist, _middleY + _cornerDist, -2, -2, 0, c_white, 1);
        }
    }
    draw_sprite(sprPlantsCounter, max((plantsCount mod 98) - 48, 0)*4/25, min(view_xview, 0)+16 + 80*i, 80+guiHeight);
}
/*
//destroy icon hotkey sign
draw_sprite(sprPlantsHotkeySign, 1, min(view_xview, 0) + 400  + 64, guiHeight);
draw_sprite(sprPlantsHotkeySign, 2, min(view_xview, 0) + 400  + 64 + 48, guiHeight);
*/

//destroy icon  (intentionally not cropped - looks better)
if (clicking != deleteInd &amp;&amp; hotkeyPressed != deleteInd){
    draw_sprite_ext(sprPlantsDestroy, 0, min(view_xview, 0) + destroyIconX, (guiHeight + destroyIconY), iconScale[deleteInd], iconScale[deleteInd], iconAngFluct*sin(iconAngSine[deleteInd]), c_white, 1);
}else{
    draw_sprite_ext(sprPlantsDestroy, 0, min(view_xview, 0) + destroyIconX, (guiHeight + destroyIconY), iconScale[deleteInd], iconScale[deleteInd], iconAngFluct*sin(iconAngSine[deleteInd]), c_ltgray, 1);
}
draw_text_outline(min(view_xview, 0) + destroyIconX, guiHeight  + 9, string("BkSp"), 1, c_black, 4);

//"fast foward" button
if (speedUp){
    draw_sprite_ext(sprPlantsSpeedup, speedUpButtonInd, min(view_xview, 0) + speedButtonX, guiHeight + 16, 2, 2, 0, c_white, 1);
}else{
    draw_sprite_ext(sprPlantsSpeedup, speedUpButtonInd, min(view_xview, 0) + speedButtonX, guiHeight + 16, 2, 2, 0, c_gray, 1);
}

/*
// The spike plant used to be an upgrade for the cannon, but this is no longer the case
//overlay for the spike upgrade
draw_set_alpha(0.4);
draw_set_color(upgradePacketColor);
draw_rectangle(min(view_xview, 0)+176, (guiHeight + 16), min(view_xview, 0)+239, 79+guiHeight, false);
draw_set_color(c_white);
draw_set_alpha(1);
draw_sprite_ext(iconSpr[1], iconSubimg[1], min(view_xview, 0)+208, (guiHeight + 24), 0.5, 0.5, 0, c_white, 0.5);
*/

//cooldown timers
draw_set_alpha(0.4);
draw_set_color(c_dkgray);
for(var i=0; i&lt;totalPlants; i++){
    if (cooldown[i] &gt; 0 || currency &lt; plantCost[i]){
        draw_rectangle(min(view_xview, 0)+16 + 80*i, 16+guiHeight, min(view_xview, 0)+79 + 80*i, 79+guiHeight, false);
        if (cooldown[i] &gt; 0){
            draw_rectangle(min(view_xview, 0)+16 + 80*i, 79 - 63*(cooldown[i]/cooldownMax[i]) + guiHeight, min(view_xview, 0)+79 + 80*i, 79 + guiHeight, false);
        }
    }
}
draw_set_alpha(1);
draw_set_color(c_white);

//currency counter
draw_sprite(sprPlantsCounter, max((plantsCount mod 98) - 48, 0)*4/25, min(view_xview, 0) + (currencyIconX+16), guiHeight + 80);
draw_sprite_ext(sprMakerCoin, 0, min(view_xview, 0) + (currencyIconX+48), guiHeight + 48, 3, 3, 0, c_white, 1);

draw_set_font(fDefault12);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

//Small GUI text
draw_set_color(currencyColor);
for(var i=0; i&lt;totalPlants; i++){
    draw_text(min(view_xview, 0)+48 + 80*i, 98+guiHeight, string(plantCost[i]));
}
draw_text(min(view_xview, 0) + (currencyIconX+48), 98+guiHeight, string(currency));
draw_set_color(c_white);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spawn Next Wave
currentWave ++;

// reset wave-specific variables
spawnArray = 0;  // clear array
spawnChoices = 0; // reset choices
waveTimer = waveStart;
waveHealthThreshold = 0;
// wave progress trackers
currentWaveHealthInit = 0;
currentWaveHealth = 0;
currentWavePointSpawned = 0;  // increased when each spawner instance activates

// Get spawn "points"
var _spawnPoints = 0;
var _inFlagWave = false;
for (var i=0; i&lt;flagCount; i++){
    if (currentWave == flagWave[i]){
        _inFlagWave = true;
        break;
    }
}
if (_inFlagWave){
    // big waves
    if (currentWave == flagWave[(flagCount-1)]){
        _spawnPoints = ceil(waveSpawnPoints * 4.25);
    }else{
        _spawnPoints = ceil(waveSpawnPoints * 3.15);
    }
    waveTimer -= hugewaveSpawnerDelay;  // increase spawner delays
}else{
    _spawnPoints = waveSpawnPoints;
}
currentWavePointTotal = _spawnPoints;

// Get maximum delay (max length of spawning period)
psuedoRNGVal = scrPlantsPsuedoRNG(psuedoRNGVal, 2.79);
var _enemySpawnDelayMult = 24;
spawnMaxDelay = clamp((currentWavePointTotal-1)/2 * _enemySpawnDelayMult, 0, 80);

// Add enemies to wave pool
scrPlantsWaveAddEnemy(ENEMY_CHERRY);  // regular Cherries (always enabled)
if (currentWave &gt;= 5){  // Cherries w/ Brown Block hat  (&gt;= wave 5)
    scrPlantsWaveAddEnemy(ENEMY_CHERRYBROWN);
}
if (currentWave &gt;= 9){  // Cherries w/ Megaman Block hat  (&gt;= wave 9)
    scrPlantsWaveAddEnemy(ENEMY_CHERRYMEGA);
}
if (currentWave &gt;= 12){  // "Hyper" (bouncing) cherries  (&gt;= wave 12)
    scrPlantsWaveAddEnemy(ENEMY_HYPERCHERRY);
}
if (currentWave &gt;= 15){  // Enemy Spikes  (&gt;= wave 15,  after guy)
    scrPlantsWaveAddEnemy(ENEMY_SPIKE);
}

//Manually generate some spawners
if ((currentWave &gt;= 17 &amp;&amp; currentWave &lt; 20) &amp;&amp; (prevRandomMikuWave &lt;= currentWave-2)){  // Miku (17 &lt;= wave &lt; 20   +   &gt;= 2 waves after last random spawn  (this means 1-2 will spawn before final wave)
    var _spawn = (currentWave == 17);
    if (!_spawn){
        psuedoRNGVal = scrPlantsPsuedoRNG(psuedoRNGVal, 4.79);
        _spawn = ((psuedoRNGVal mod 60) &gt;= 36);
    }
    if (_spawn){
        scrPlantsGenEnemySpawner(ENEMY_MIKU);
        _spawnPoints -= enemySpawnCost[ENEMY_MIKU];
        prevRandomMikuWave = currentWave;
    }
}

if (currentWave == 20){  // Miku
    scrPlantsGenEnemySpawner(ENEMY_MIKU);
    _spawnPoints -= enemySpawnCost[ENEMY_MIKU];
}
if (currentWave == 13){  // The Guy  (always one on wave 13)
    scrPlantsGenEnemySpawner(ENEMY_THEGUY);
    _spawnPoints -= enemySpawnCost[ENEMY_THEGUY];
}
if (currentWave == 11){  // introduce the spike on wave 11
    scrPlantsGenEnemySpawner(ENEMY_SPIKE);
    _spawnPoints -= enemySpawnCost[ENEMY_SPIKE];
}

//huge wave leader
if (_inFlagWave){
    scrPlantsGenEnemySpawner(ENEMY_CHERRY);
    with (objPlantsEnemySpawner){
        if (wave == other.currentWave &amp;&amp; enemy == other.enemySpawnObject[other.ENEMY_CHERRY]){
            subtype = 3;  // carrying the flag
            delay = max(((16*((floor(other.psuedoRNGVal) div 10) mod 6)/6) - other.waveTimer) - 40, 0);
            spawnedEnemyAnimMult = 1.6;  // should be significantly faster than the fastest regular enemy
        }
    }
    _spawnPoints -= enemySpawnCost[ENEMY_CHERRY];
}

//spawn the wave
scrPlantsSpawnWave(_spawnPoints);
if (_inFlagWave){
    waveTimer = hugewaveStart;  // we used a different value to influence the spawner delay
    if (currentWave == waveTotal){roundState = 2;}
//}else if (currentWave &gt; 0 &amp;&amp; currentWave &lt;= 2){
    //waveTimer -= ((2-currentWave) + 1)*125;   // add a slightly longer delay at the start to give players who don't understand PvZ mechanics time to prepare
}else if (currentWave == (flagWave[0]+1)){
    waveTimer -= 64;  // recovery time from the stronger waves
}

//increase spawn points for future waves
var _waveCheck = (floor(currentWave-1) mod 5) + 1;
if (_waveCheck == 3 || _waveCheck == 5){  // third and fifth wave in each group of 5
    waveSpawnPoints += 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init Plant+Wave Information

//  PLANTS  \\
plantObj[5] = objPlantsActivator;
plantObj[4] = objPlantsShuriken;
plantObj[3] = objPlantsSpringtrap;
plantObj[2] = objPlantsSpike; //upgrade from cannon
plantObj[1] = objPlantsCannon;
plantObj[0] = objPlantsCoinBlock;

plantCost[5] = 10;
plantCost[4] = 50;
plantCost[3] = 30;
plantCost[2] = 45;
plantCost[1] = 25;
plantCost[0] = 15;

iconSpr[5] = sprMakerActivator;
iconSpr[4] = sprPlantsShurikenSmall;
iconSpr[3] = sprPlantsSpringIcon;
iconSpr[2] = sprPlantsSpikeIcon;
iconSpr[1] = sprPlantsCannonIcon;
iconSpr[0] = sprPlantsCoinBlockIcon;

iconScaleMult[2] = 0.72;  // spike launchers
gridScaleMult[5] = 1.5;  // activators (mines)

cooldownMax[5] = 750;
cooldownMax[4] = 1700;
cooldownMax[3] = 1450;
cooldownMax[2] = 700;
cooldownMax[1] = 300;
cooldownMax[0] = 300;

for(var i=(totalPlants-1);i&gt;=1;i--){  // should only be able to place coin blocks at the start 
    cooldown[i] = cooldownMax[i];
}
//  END  PLANTS  \\

iconSpr[6] = sprPlantsDestroy;

//  WAVES  \\
waveTotal = 20;
flagWave[0] = 10;  flagWave[1] = 20;
flagCount = array_length_1d(flagWave);

//Enemy health and spawn "cost"
enemyTotal = 8;
ENEMY_CHERRY = 0;
ENEMY_CHERRYBROWN = 1;
ENEMY_CHERRYMEGA = 2;
ENEMY_HYPERCHERRY = 3;
ENEMY_SPIKE = 4;
ENEMY_MIKU = 5;
ENEMY_THEGUY = 6;
var _defaultHP = 7;

enemySpawnObject[(enemyTotal-1)] = 0;
enemySpawnSubtype[(enemyTotal-1)] = 0;
for (var i=(enemyTotal-1); i&gt;=0; i--){
    enemySpawnObject[i] = 0;
    enemySpawnSubtype[i] = 0;
    enemySpawnHealth[i] = _defaultHP;
    enemySpawnCost[i] = 1;
    enemySpawnWeight[i] = 1;
}

//Enemy objects
enemySpawnObject[ENEMY_CHERRY] = objPlantsCherry;
enemySpawnObject[ENEMY_CHERRYBROWN] = objPlantsCherry;
enemySpawnObject[ENEMY_CHERRYMEGA] = objPlantsCherry;
enemySpawnObject[ENEMY_HYPERCHERRY] = objPlantsHyperCherry;
enemySpawnObject[ENEMY_SPIKE] = objPlantsIWBTGSpike;
enemySpawnObject[ENEMY_MIKU] = objPlantsMiku;
enemySpawnObject[ENEMY_THEGUY] = objPlantsGuy;

enemySpawnSubtype[ENEMY_CHERRYBROWN] = 1;
enemySpawnSubtype[ENEMY_CHERRYMEGA] = 2;

//Health
enemySpawnHealth[ENEMY_CHERRYBROWN] = 7 + (8);  // includes hat durability
enemySpawnHealth[ENEMY_CHERRYMEGA] = 7 + (8 + 6*1);  // includes hat durability
enemySpawnHealth[ENEMY_SPIKE] = 3;
enemySpawnHealth[ENEMY_MIKU] = 10;
var _boshyHP = 5;  // probably not needed
enemySpawnHealth[ENEMY_THEGUY] = 32;

//Cost
enemySpawnCost[ENEMY_CHERRY] = 1;
enemySpawnCost[ENEMY_CHERRYBROWN] = 2;
enemySpawnCost[ENEMY_CHERRYMEGA] = 3;
enemySpawnCost[ENEMY_HYPERCHERRY] = 2;
enemySpawnCost[ENEMY_SPIKE] = 3;
enemySpawnCost[ENEMY_MIKU] = 6;
enemySpawnCost[ENEMY_THEGUY] = 7;

//Weighted probability (defaults  --  can be overwritten in scrPlantsSetupWave)
enemySpawnWeight[ENEMY_CHERRY] = 9;
enemySpawnWeight[ENEMY_CHERRYBROWN] = 5;
enemySpawnWeight[ENEMY_CHERRYMEGA] = 2;
enemySpawnWeight[ENEMY_HYPERCHERRY] = 3;
enemySpawnWeight[ENEMY_SPIKE] = 4;
enemySpawnWeight[ENEMY_MIKU] = 2;
enemySpawnWeight[ENEMY_THEGUY] = 0;  // doesn't spawn randomly

//  Cherry:
//  Cherry + Brown block:
//  Cherry + Megaman block:
//  Hyper Cherry:
//  Spike:
//  Miku:
//  The Guy (+Boshy):

prevRandomMikuWave = 0;
//  END  WAVES  \\
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spawn Laser
psuedoRNGVal = scrPlantsPsuedoRNG(psuedoRNGVal, 8.79);
var _laserGridSlot = (floor(psuedoRNGVal) mod 60) mod 24;  // intentionally biased;  numbered  top-&gt;bottom, left-&gt;right
var _laserCol, _laserRow;
_laserCol = (_laserGridSlot div rows);
_laserRow = (_laserGridSlot mod rows);

//attempt to target a living plant
if (instance_exists(objPlantsPlant)){  // no point checking for a living plant if there are no plants
    var _slotsChecked = 0;
    while ((!instance_exists(plantGrid[_laserCol, _laserRow]) || (instance_exists(plantGrid[_laserCol, _laserRow]) &amp;&amp; plantGrid[_laserCol, _laserRow].dead)) || (collision_point(128 + _laserCol*64, 192 + _laserRow*64, objPlantsLaser, false, true) == noone)){
        _laserRow ++;
        if (_laserRow &gt;= rows){
            _laserRow = 0;
            _laserCol = (_laserCol + 1) mod columns;
        }
        _slotsChecked ++;
        if (_slotsChecked &gt;= (rows * columns)){  // checked every slot
            if (collision_point(128 + _laserCol*64, 192 + _laserRow*64, objPlantsLaser, false, true) == noone){  // never spawn two lasers on top of each other
                break;
            }
        }
    }
}
with (instance_create(128 + _laserCol*64, 192 + _laserRow*64, objPlantsLaser)){
    plantTargetColumn = _laserCol;
    plantTargetRow = _laserRow;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_destroy, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug Overlay
if (global.debugOverlay)
{
    draw_set_font(fDefault12);
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
    scrDrawTextOutlineMinimal( + 64, +104, "Current Wave:  " + string(currentWave), c_white, c_black);
    if (waveTimer &gt;= minWaveDelay){draw_set_color(c_green);}else{draw_set_color(c_red);}
    draw_text( + 64, +116, "Wave Timer:  " + string(waveTimer));
    draw_text( + 256, +116, "( Min:  " + string(minWaveDelay) + "; Max:  " + string(maxWaveDelay) + " )");
    if (currentWaveHealthInit &lt;= floor(currentWaveHealthInit*waveHealthThreshold)){draw_set_color(c_green);}else{draw_set_color(c_red);}
    draw_text( + 64, +128, "Wave Health:  " + string(scrPlantsWaveHP(currentWave)) + " / " + string(currentWaveHealthInit) + ";");  // will display correct value, even before currentWaveHealth is calculated in Step Event
    draw_text( + 256, +128, "( Threshold:  &lt;= " + string(floor(currentWaveHealthInit*waveHealthThreshold))  + "  [" + string(round(100*waveHealthThreshold)) + "%] )");
    if (currentWavePointSpawned &gt;= currentWavePointTotal){draw_set_color(c_green);}else{draw_set_color(c_red);}
    draw_text( + 64, +140, "Used Spawn Points:  " + string(currentWavePointSpawned) + " / " + string(currentWavePointTotal));
    draw_text( + 64, +156, "Previous PsuedoRNG Value:  " + string(psuedoRNGVal));
    draw_text( + 64, +172, "Real FPS:  " + string(fps_real));
    draw_set_color(c_white);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///do nothing
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug
/*
show_debug_message("PLANTS:");
with (objPlantsPlant){
    show_debug_message(object_get_name(object_index));
}
show_debug_message("ENEMIES:");
with (objPlantsEnemy){
    show_debug_message(object_get_name(object_index));
}

show_debug_message("GORE SPRITES:");
with (objPlantsGore){
    show_debug_message(sprite_get_name(sprite_index) + "-" + string(state));
}

show_debug_message("PLANT PARTS:");
with (objPlantsGore){
    show_debug_message(sprite_get_name(sprite_index));
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
