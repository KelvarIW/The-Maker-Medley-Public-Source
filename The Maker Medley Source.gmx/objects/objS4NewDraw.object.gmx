<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprCamera</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-20</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Rift edge particles
riftBodySurf = -4;
riftEndSurf = -4;
riftBodyBuffer = 32;
riftPieceSize = 128;
ParticleInit = false;

if (instance_number(object_index) &gt; 1){
    instance_destroy();  // after surface variables are initialized
}

alarm[1] = 1;  // initialize particle System
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Free surfaces
event_perform(ev_other, ev_room_end);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize rift border particles

// circle radius
ParticleNumBody = 48;
ParticleNumEnd = 32;
partSpawnRadMin = 14;
partSpawnRadMax = 20;
partRadMin = 1;
bodyRadDec = 0.36;
endRadDec = 0.36;

// movement speed
ParticleSideMax = 1.4;
ParticleOutMax = 1.2;
ParticleOutMin = 1.0;
ParticleSpdThresh = 0.8;

// rift particle spawn regions
bodyLeft = 64 - 30;
bodyRight = 64 + 30;
bodyTop = 0;
bodyBottom = 128;

// Spawn initial particles
if (ParticleNumBody &gt;= 1){
    for (var i = (ParticleNumBody-1); i &gt;= 0; i--){
        // shared between left and right particles for slight performance boost
        var _rad = random_range(partSpawnRadMin, partSpawnRadMax);  // radius of particles
        var _hspd = random_range(ParticleOutMin, ParticleOutMax);   // absolute value
        var _vspd = random_range(-(ParticleSideMax), ParticleSideMax);
        //spd threshold
        var _check = max(sqrt( sqr(_hspd) + sqr(_vspd) ) / ParticleSpdThresh, 1);
        _hspd /= _check;
        _vspd /= _check;
        
        // create side particles
        bodyPartRad[i] = _rad;
        bodyPartX[i] = -_rad;
        bodyPartY[i] = random_range(bodyTop, bodyBottom);
        bodyPartHspd[i] = _hspd;
        bodyPartVspd[i] = _vspd;
        
        // simulate frames of particle life
        var _frames = floor(i/ParticleNumBody * max((_rad - partRadMin)/bodyRadDec, 0));
        var _simRad = bodyRadDec * _frames;
        var _simHspd = _hspd * _frames;
        var _simVspd  = _vspd * _frames;
        
        bodyPartRad[i] -= _simRad;
        bodyPartX[i] += _simHspd;
        bodyPartY[i] += _simVspd;
    }
}

if (ParticleNumEnd &gt;= 1){
    for (var i = (ParticleNumEnd-1); i &gt;= 0; i--){
        // pre-calculate values
        var _rad = random_range(partSpawnRadMin, partSpawnRadMax);  // radius of particles
        var _spd = random_range(ParticleOutMin, ParticleOutMax);
        var _ang = random(180);
        var _hspd = _spd  *   dcos(_ang);
        var _vspd = _spd  * (-dsin(_ang));
        
        // create end particles
        endPartRad[i] = _rad;
        endPartX[i] = 0
        endPartY[i] = 0;
        endPartHspd[i] = _hspd;
        endPartVspd[i] = _vspd;
        
        // simulate frames of particle life
        var _frames = floor(i/ParticleNumEnd * max((_rad - partRadMin)/endRadDec, 0));
        var _simRad = endRadDec * _frames;
        var _simHspd = _hspd * _frames;
        var _simVspd  = _vspd * _frames;
        
        endPartRad[i] -= _simRad;
        endPartX[i] += _simHspd;
        endPartY[i] += _simVspd;
    }
}

alarm[1] = -1;  // in case it's called manually
ParticleInit = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Needed if coming from "Load Game" menu
if (instance_exists(objPlayer)){
    if (room == rStage04New_1){
        /*  // No longer needed after Kurath rework
        // Destroy kill blocks if they would have had to be destroyed before
        var _checkX = -100;
        if (instance_exists(objPlayer)){
            _checkX = objPlayer.x;
        }else{
            _checkX = global.savePlayerX;  //???
        }
        if (_checkX != -100 &amp;&amp; _checkX &gt; 464){
            with (objMakerKillBlock){
                if (object_index == objMakerKillBlock &amp;&amp; y &lt; 240){  // don't destroy children (i.e. objS1KillblockCircular)
                    instance_destroy();
                }
            }
        }
        */
    }else if (room == rStage04New_3){
        if (objPlayer.x &gt; 704 || objPlayer.y &lt; 240){
            //Klamy
            with (objMakerTrigger){
                if (trigger == 4){
                    event_perform(ev_collision, objPlayer);
                }
            }
            // Abstr4kt 2
            if (objPlayer.x &lt; 704 &amp;&amp; objPlayer.y &lt; 240){
                with (objMakerTrigger){
                    if (trigger == 5){
                        event_perform(ev_collision, objPlayer);
                    }
                }
            }
            
            with (objS4NewRift){
                if (speed &gt; 0 &amp;&amp; alarm[0] &gt; 0){
                    x += hspeed*ceil(alarm[0]);
                    y += vspeed*ceil(alarm[0]);
                    speed = 0;
                }
            }
            with (objS4NewRiftNokill){
                if (alarm[0] &gt; 0){
                    instance_destroy();
                }
            }
        }
    }else if (room == rStage04New_4){
        if (objPlayer.x &gt; 880){
            with (objMakerTrigger){
                event_perform(ev_collision, objPlayer);
            }
            with (objS4NewRift){
                if (speed &gt; 0 &amp;&amp; alarm[0] &gt; 0){
                    x += hspeed*ceil(alarm[0]);
                    y += vspeed*ceil(alarm[0]);
                    speed = 0;
                }
            }
            with (objS4NewRiftNokill){
                if (alarm[0] &gt; 0){
                    instance_destroy();
                }
            }
            with (objMakerTrigger){
                instance_destroy();
            }
        }
    }
}else{
    alarm[0] = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Manage rift border particles
if (ParticleInit){
    for (var i = (ParticleNumBody-1); i &gt;= 0; i--){
        bodyPartRad[i] -= bodyRadDec;
        if (bodyPartRad[i] &lt;= partRadMin){
            //generate new particle
            var _rad = random_range(partSpawnRadMin, partSpawnRadMax);  // radius of particles
            var _hspd = random_range(ParticleOutMin, ParticleOutMax);   // absolute value
            var _vspd = random_range(-(ParticleSideMax), ParticleSideMax);
            //spd threshold
            var _check = max(sqrt( sqr(_hspd) + sqr(_vspd) ) / ParticleSpdThresh, 1);
            _hspd /= _check;
            _vspd /= _check;
            
            bodyPartRad[i] = _rad;
            bodyPartX[i] = -_rad;
            bodyPartY[i] = random_range(bodyTop, bodyBottom);
            bodyPartHspd[i] = _hspd;
            bodyPartVspd[i] = _vspd;
        }else{
            bodyPartX[i] += bodyPartHspd[i];
            bodyPartY[i] += bodyPartVspd[i];
        }
    }
    for (var i = (ParticleNumEnd-1); i &gt;= 0; i--){
        endPartRad[i] -= endRadDec;
        if (endPartRad[i] &lt;= partRadMin){
            // pre-calculate movement values
            var _rad = random_range(partSpawnRadMin, partSpawnRadMax);  // radius of particles
            var _spd = random_range(ParticleOutMin, ParticleOutMax);
            var _ang = random(180);
            var _hspd = _spd  *   dcos(_ang);
            var _vspd = _spd  * (-dsin(_ang));
            
            // generate new particle
            endPartRad[i] = _rad;
            endPartX[i] = 0;
            endPartY[i] = 0;
            endPartHspd[i] = _hspd;
            endPartVspd[i] = _vspd;
        }else{
            endPartX[i] += endPartHspd[i];
            endPartY[i] += endPartVspd[i];
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Free surfaces
if (surface_exists(riftBodySurf)){surface_free(riftBodySurf);}
if (surface_exists(riftEndSurf)){surface_free(riftEndSurf);}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Destroy outside Stage 4
if (!(room == rStage04New_1 || room == rStage04New_2 || room == rStage04New_3 || room == rStage04New_4)){
    instance_destroy();
    exit;
}

// Close rifts that have been passed
//alarm[0] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Generate rift surfaces
if (ParticleInit){
    if (!surface_exists(riftBodySurf)){
        riftBodySurf = surface_create(riftPieceSize, riftPieceSize + (2*riftBodyBuffer));
    }
    if (surface_exists(riftBodySurf)){
        surface_set_target(riftBodySurf);
        draw_clear_alpha(c_black, 0);
        
        draw_sprite_ext(sprS4Rift, 0, 64, riftBodyBuffer, 2, 2, 0, c_white, 1);
        for (var i = (ParticleNumBody-1); i &gt;= 0; i--){
            draw_circle(bodyRight + bodyPartX[i], bodyPartY[i] + riftBodyBuffer, bodyPartRad[i], false);
            draw_circle(bodyLeft - bodyPartX[i], (riftPieceSize - bodyPartY[i]) + riftBodyBuffer, bodyPartRad[i], false);
        }
        surface_reset_target();
    }
    
    if (!surface_exists(riftEndSurf)){
        riftEndSurf = surface_create(riftPieceSize, riftPieceSize);
    }
    if (surface_exists(riftEndSurf)){
        surface_set_target(riftEndSurf);
        draw_clear_alpha(c_black, 0);
        
        draw_sprite_ext(sprS4RiftEdge, 0, 64, 64, 2, 2, 0, c_white, 1);
        for (var i = (ParticleNumEnd-1); i &gt;= 0; i--){
            draw_circle(64 + endPartX[i], 64 + endPartY[i], endPartRad[i], false);
        }
        surface_reset_target();
    }
}

if (!surface_exists(global.sharedSurf)){
    global.sharedSurf = surface_create(800, 608);
}

if (surface_exists(global.sharedSurf)){
    surface_set_target(global.sharedSurf);
    draw_clear_alpha(c_black, 0);
    //create image
    scrDrawTexturedArea(global.galaxyBackTex, (view_xview) mod 64, (view_yview) mod 64, 0, 0, 800, 608);
    scrDrawTexturedArea(global.galaxyStarTex, (view_xview - (global.countPersistent/2)) mod 64, (view_yview - (-global.countPersistent/2)) mod 64, 0, 0, 800, 608);
    //set alpha to 0
    draw_set_colour_write_enable(false, false, false, true);
    draw_set_blend_mode(bm_subtract);
    draw_rectangle(0, 0, 800, 608, false);
    draw_set_blend_mode(bm_normal);
    
    if (instance_exists(objMakerParachute)){
        with (objMakerParachute){
            draw_sprite_ext(sprS4ParachuteOut, 0, x-view_xview, y-view_yview, image_xscale, image_yscale*flipAmt/16, image_angle, c_white, image_alpha);
        }
        //should not have the outline in the "screen" it's from (this assumes the room is rStage04New_1)
        draw_set_blend_mode(bm_subtract);
        draw_rectangle(448  -view_xview + 0.5, 256  -view_yview + 0.5, 800 -view_xview + 0.5, 608  -view_yview + 0.5, false);
        //parachute is drawn behind tiles
        with (objBlock){
            draw_rectangle(bbox_left-view_xview, bbox_top-view_yview, bbox_right-view_xview, bbox_bottom-view_yview, false);
        }
        draw_set_blend_mode(bm_normal);
    }
    
    draw_set_colour_write_enable(true, true, true, true);
    surface_reset_target();
    
    //draw surface  
    if (surface_exists(global.sharedSurf)){
        draw_surface_ext(global.sharedSurf, view_xview, view_yview, 1, 1, 0, c_white, 1);
        draw_surface_ext(global.sharedSurf, view_xview, view_yview, 1, 1, 0, c_white, 1);
    }
}

if (surface_exists(global.sharedSurf)){
    surface_set_target(global.sharedSurf);
    draw_clear_alpha(c_black, 0);
    //create image
    scrDrawTexturedArea(global.galaxyBackTex, (view_xview) mod 64, (view_yview) mod 64, 0, 0, 800, 608);
    scrDrawTexturedArea(global.galaxyStarTex, (view_xview - (global.countPersistent/2)) mod 64, (view_yview - (-global.countPersistent/2)) mod 64, 0, 0, 800, 608);
    
    draw_set_colour_write_enable(false, false, false, true);
    //set alpha to 0
    draw_set_blend_mode(bm_subtract);
    draw_rectangle(0, 0, 800, 608, false);
    draw_set_blend_mode(bm_normal);
    
    with (objS4NewRiftNokill){
        event_user(0);
    }
    with (objMakerCirclePart){
        if (rift){
            draw_circle(x - view_xview, y - view_yview, rad, false);
        }
    }
    draw_set_colour_write_enable(true, true, true, true);
    surface_reset_target();
    
    //draw surface
    if (surface_exists(global.sharedSurf)){
        var _alpha = 1;
        var _blend = c_gray
        if (global.colorBlind){
            //_alpha = 0.8;
            _blend = c_dkgray;
        }
        draw_surface_ext(global.sharedSurf, view_xview, view_yview, 1, 1, 0, _blend, _alpha);
    }
}
with (objPlayer){
    event_perform(ev_draw, 0);
}
with (objMakerTelePlayer){
    event_perform(ev_draw, 0);
}
with (objS2FlappyShip){
    event_perform(ev_draw, 0);
}
if (surface_exists(global.sharedSurf)){
    draw_set_colour_write_enable(true, true, true, true);
    surface_set_target(global.sharedSurf);
    draw_clear_alpha(c_black, 0);
    //create image
    scrDrawTexturedArea(global.galaxyBackTex, (view_xview) mod 64, (view_yview) mod 64, 0, 0, 800, 608);
    scrDrawTexturedArea(global.galaxyStarTex, (view_xview - (global.countPersistent/2)) mod 64, (view_yview - (-global.countPersistent/2)) mod 64, 0, 0, 800, 608);
    
    //set alpha to 0, except in some locations
    draw_set_colour_write_enable(false, false, false, true);
    
    //set all to 0
    draw_set_blend_mode(bm_subtract);
    draw_rectangle(0, 0, 800, 608, false);
    draw_set_blend_mode(bm_normal);
    
    //fill in certain areas
    
    // borders
    /*
    draw_rectangle(0-view_xview, 0, 104-view_xview  -.5, 608, false);
    if (room != rStage04New_4){
        draw_rectangle((room_width-104)-view_xview  +.5, 0, room_width-view_xview, 608, false);
    }
    
    draw_set_blend_mode(bm_subtract);
    draw_sprite_ext(sprS4HorizontalFade, 0, 104-view_xview, 0, -1, 19, 0, c_black, 1);
    if (room != rStage04New_4){
        draw_sprite_ext(sprS4HorizontalFade, 0, (room_width-104)-view_xview, 0, 1, 19, 0, c_black, 1);
    }
    draw_set_blend_mode(bm_normal);
    */
    
    with (objS4NewRift){
        event_user(0);
    }
    with (objS4NewRiftSquare){
        draw_rectangle(bbox_left-view_xview, bbox_top-view_yview, bbox_right-view_xview, bbox_bottom-view_yview, false);
    }
    draw_set_colour_write_enable(true, true, true, true);
    surface_reset_target();
    
    //draw surface
    if (surface_exists(global.sharedSurf)){
        //draw_surface_ext(global.sharedSurf, view_xview, view_yview, 1, 1, 0, c_white, 1);
        draw_surface_ext(global.sharedSurf, view_xview, view_yview, 1, 1, 0, c_white, 1);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
