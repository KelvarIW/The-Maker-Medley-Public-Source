<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprMrScribble</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>objFinalBossScribbleParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Initialize
event_inherited();
// Overwrite Parent Defaults
currentHPVal = 5;

//attacks + selection system
attackNum = 10;
for (var i = attackNum-1; i &gt;= 0; i--){ //initialize the array
    attack[i] = -1;
}

introTimer = 0;
dieChangeState = 0;

phase = 0; //0 = intro
phaseTimer = 0;
spawnSide = 1;

//Buff only
buffPhaseEndCount = 0;  // only set new phases once both have ended
buffPhase = -1;  // right fragment phase

leftDiePiece = -4;
rightDiePiece = -4;

//note: in buffed mode, the shared attack-controlling variables are set to and from these variables before each attack is run
leftPhaseIndex = -1;
rightPhaseIndex = -1;
leftPhaseTimer = 0;
rightPhaseTimer = 0;
leftSpawnSide = 1;
rightSpawnSide = 1;

// Reshuffling attack priorities
buffDualAttacks = false;  // old buff attempt
if (buffDualAttacks){
    prevPhasesToTrack = 4;  // 2 attacks are active at a time
}else{
    prevPhasesToTrack = 4;
}
for (var i=(prevPhasesToTrack-1); i&gt;=0; i-=1;){
    phaseLast[i] = -1;
    prevPhaseNewIndex[i] = -1;
}

//practice mode
practiceAttackNum = 0; //0 if we're:    not in practice mode OR not starting from P4 OR not setting attacks with the window
practiceAttackIndex = 0;
if (global.practicing &amp;&amp; global.practiceWaypointStart == 8){
    for (var i = attackNum; i&gt;0; i--){
        if (practiceAttackNum == 0 &amp;&amp; global.practiceFinalBossVal[i-1] &gt; 0){
            practiceAttackNum = i;
        }
    }
}
for (var i = practiceAttackNum-1; i &gt;= 0; i--){ //we use a separate array so the same attack can repeat multiple times
     practiceAttack[i] = -1;
}

//transition + intro
blockHeight = 1088;
ystart = 386;
destY = 608 + 188;
autosave = false;
started = true;

//save the attack the player dies on, and start with it when the player restarts the fight UNLESS they died to that attack on their previous attempt.
//should be set to false if starting with the attack that previously killed the player.
//should be set to true once the player beats that attack.
//NOTE: if the player beats the attack, survives all other attacks, and then dies on the initial attack once the attacks are reshuffled, their next attempt will start with the same attack as that attempt.
//this behavior is intentional, as the situation that causes it shows the player is inconsistent against the attack in question.
storeDeathAttack = (!buffDualAttacks &amp;&amp; global.scribbleP4LastDeath &lt;= 0);  // no need to use this in the buffed version

event_user(0); //assign priority to each randomly-selected attack

//misc.
xCent = xstart;
yCent = destY;
yCentRise = 0;
movementTimer = 0;
initialAccel = 0;
yoyoSpeed = 1;

//Ending
eraseXOff = 0;
eraseYOff = 0;
erasable = -1;
erasingHP = 400;
if (buff()){
    erasingHP = 580;
}
erasingHPInit = erasingHP;
eraseSFXPitch = 1;
eraseSFXDelay = 0;
eraseSlowdown = 1;
eraseStartViewAng = 0;
erasableTransitionTime = 60;

//deletion "shaking" effect
eraseShakePieceTargetInit = 12;
eraseShakePieceTarget = eraseShakePieceTargetInit;
eraseShakePieceTargetMax = 12;
eraseShakePieceBursts = 4;
eraseShakePieceTimer = 0;
eraseShakePieceLifespan = 12;
eraseShakePieceDelay = (eraseShakePieceLifespan / eraseShakePieceBursts);
for (var i=eraseShakePieceTargetMax-1; i &gt;= 0; i--){
    eraseShakeX[i] = 0;
    eraseShakeY[i] = 0;
    eraseShakeHspd[i] = 0;
    eraseShakeVspd[i] = 0;
    eraseShakeAlpha[i] = 0;
}

dying = false;
dyingViewChangeCount = 0;
dyingStoredViewValues[4] = 0;

//Final Attack - Practice Mode Waypoint
if (global.practicing &amp;&amp; global.practiceWaypointStart == 9){
    global.finalBossHPPracticeTemp = 0;
    leftPhaseIndex = -1;
    rightPhaseIndex = -1;
    erasable = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Transtion to final subphase
with (objFinalBossHP){
    descend = -1;
}
erasable = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Make RNG Die shrink if player dies
if (global.dead){
    dieChangeState = -1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Inherit parent code
event_inherited();
if (started &amp;&amp; erasable == -1){
    if (global.dead &amp;&amp; storeDeathAttack){
        global.scribbleP4LastDeath = phase;
    }
}

if (!dying){
    if (erasable &gt;= 0){
        phaseTimer ++;
        if (!global.dead &amp;&amp; instance_exists(objPlayer) &amp;&amp; erasable == 1 &amp;&amp; phase != 0 &amp;&amp; erasingHP &gt; 0){
            with (objFinalRNGDie){
                grow = true;
                shrink = false;
                if (latchedOn){
                    appearYDiff = 108;
                    if (buff()){
                        appearXDiff = 64*part;
                    }
                }
            }
            if (phaseTimer &gt; 30 &amp;&amp; (phaseTimer mod 4) == 1){
                var _inst = instance_create(x+irandom_range(-47, 47), y+irandom_range(-47, 47), objFinalP4DeletionProj);
                _inst.hspeed *= spawnSide;
                spawnSide = -spawnSide;
                
                audio_stop_sound(sndMakerSampleThrow);
                audio_sound_pitch(audio_play_sound(sndMakerSampleThrow, 0, 0), random_range(0.65, 0.75));
            }
            if (mouse_check_button(mb_right) &amp;&amp; instance_exists(objMouseClickCheck) &amp;&amp; objPlayer.y &lt; 1150){
                var _hspd = x-xprevious;
                var _vspd = y-yprevious;
                var _dist = point_distance(objMouseClickCheck.xprevious + _hspd, objMouseClickCheck.yprevious + _vspd, objMouseClickCheck.x, objMouseClickCheck.y);
                var _distCap = 15, _distPerDmg = 5; //used for calculating damage
                if (_dist != 0){
                    var _colCurr = (collision_point(objMouseClickCheck.x, objMouseClickCheck.y, id, true, false) != noone);
                    var _colPrev = (collision_point(objMouseClickCheck.xprevious + _hspd, objMouseClickCheck.yprevious + _vspd, id, true, false) != noone);
                    if (_colCurr || _colPrev){
                        if ((_colCurr &amp;&amp; !_colPrev) || (!_colCurr &amp;&amp; _colPrev)){ //total distance traveled is not the distance traveled over the object. (There are some other edge cases given the sprite's irregular shape, but let's ignore that :)  )
                            var _dir = point_direction(objMouseClickCheck.xprevious + _hspd, objMouseClickCheck.yprevious + _vspd, objMouseClickCheck.x, objMouseClickCheck.y);
                            var _xInc = dcos(_dir), _yInc = (-dsin(_dir));
                            if (_colCurr){
                                with (objMouseClickCheck){
                                    for(var i = _distCap; i &gt; 0; i--){
                                        if (place_meeting(x - _xInc*i, y - _yInc*i, other)){
                                            _dist = i;
                                            break;
                                        }
                                    }
                                }
                            }else{ //_colPrev
                                with (objMouseClickCheck){
                                    for(var i = _distCap; i &gt; 0; i--){
                                        if (place_meeting(xprevious + _hspd + _xInc*i, yprevious + _vspd + _yInc*i, other)){
                                            _dist = i;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        _dist = min(_dist, _distCap, erasingHP*_distPerDmg);
                        erasingHP -= _dist/_distPerDmg;
                        if (eraseSFXDelay &lt;= 0){
                            audio_stop_sound(sndFinalP4EditorDelete);
                            var _snd = audio_play_sound(sndFinalP4EditorDelete, 0, 0);
                            audio_sound_pitch(_snd, lerp(0.333, 0.8, eraseSFXPitch));
                            eraseSFXPitch = max(eraseSFXPitch - (clamp(_dist / (_distCap/2), 0.5, 1) / 40), 0);
                            eraseSFXDelay = 3;
                        }
                        with (objFinalP4PartCtrl){
                            delPartSpawnCoords[0] = objMouseClickCheck.xprevious;
                            delPartSpawnCoords[1] = objMouseClickCheck.yprevious;
                            delPartSpawnCoords[2] = objMouseClickCheck.x;
                            delPartSpawnCoords[3] = objMouseClickCheck.y;
                            delPartSpawnCoords[4] = (_dist/_distPerDmg) * 6;
                            recalculateEndpoints = !(_colCurr &amp;&amp; _colPrev);
                            event_user(0);
                        }
                        
                        if (erasingHP &lt;= 0){
                            if (!global.practicing){
                                dying = true;
                            }else{
                                scrPracticeEnd();
                                audio_play_sound(sndMakerSampleGlass, 0, 0);
                            }
                            
                            phaseTimer = 0;
                            scrFinalUpdateFarthest();
                            fadeTo = -1;
                            image_speed = 0;
                            dieChangeState = -1;
                            
                            with(objFinalP4KurathSpikeShard){
                                shrink = true;
                                speed = 0;
                                gravity = 0;
                            }
                            with (objFinalP4DeletionProj){
                                shrink = true;
                                speed = 0;
                                gravity = 0;
                            }
                            with (objPlayer){
                                var _inst = instance_create(x, y, objFakePlayer);
                                scrCopyAspects(_inst);
                                _inst.djump = djump;
                                instance_destroy();
                            }
                            
                            with (objWorld){
                                global.musicFading = global.currentMusic;
                                global.musicFadeDec = 1/30;
                                global.musicFadeEnd = "stop";
                            }
                            with (objMakerCamera){
                                instance_destroy();
                            }
                            with (objFinalRNGDie){
                                grow = false;
                                shrink = true;
                            }
                        }
                    }
                }
            }
            if (eraseSFXDelay &gt;= -5){
                eraseSFXDelay --;
            }else{
                if (eraseSFXPitch &lt; 1){
                    eraseSFXPitch = min(eraseSFXPitch + 1/40, 1)
                }
            }
        }
        eraseXOff = irandom_range(-2, 2);
        eraseYOff = irandom_range(-2, 2);
    }
}
if (dying &amp;&amp; !global.practicing){
    phaseTimer ++;
    switch (floor(phaseTimer)){
        case 1:
        //+60
        case 61:
        //+50
        case 111:
        //+45
        case 156:
        //+50
        case 206:
        //+45
        case 251:
        //+40
        case 291:
        //+30
        case 321:
        //+20
        case 341:
        //+15
        case 356:
        //+10
        case 366:
        //+10
        case 376:
        //+5
        case 381:
        //+10
        case 391:
        //+10
        case 401:
        //+5
        case 406:
        //+5
        case 411:
        //+5
        case 416:
        //+5
        case 421:
        //+5
        case 426:
            dyingViewChangeCount ++;
            var _totalChanges = 20;
            var _progress = (dyingViewChangeCount/_totalChanges) * 0.5;
            
            view_xview = lerp(0, x-40,  _progress);
            view_yview = 608 + lerp(0, (y-608)-30.4,  _progress);
            view_wview = lerp(800, 80, _progress);
            view_hview = lerp(608, 60.8, _progress);
            view_angle -= 720 / _totalChanges;
            
            if (phaseTimer == 426){
                dyingStoredViewValues[0] = view_xview;
                dyingStoredViewValues[1] = view_yview;
                dyingStoredViewValues[2] = view_wview;
                dyingStoredViewValues[3] = view_hview;
                dyingStoredViewValues[4] = angle_difference(view_angle, 0);
            }
            
            with (objFinalP4PartCtrl){
                delPartSpawnCoords[0] = other.x;
                delPartSpawnCoords[1] = other.y;
                delPartSpawnCoords[2] = other.sprite_width;
                delPartSpawnCoords[3] = other.sprite_height;
                delPartsToCreate = irandom_range(48, 64);
                event_user(1);
            }
            
            var _snd;
            _snd = audio_play_sound(sndMakerSampleGlass, 0, 0);
            audio_sound_pitch(_snd, random_range(0.95, 1) + 0.45*_progress);
            _snd = audio_play_sound(sndFinalP4EditorDelete, 0, 0);
            audio_sound_pitch(_snd, random_range(0.95, 1) + 0.45*_progress);
            audio_sound_gain(_snd, 1.6 * (global.sfxLevel/100 * global.volumeLevel/100), 0);
            break;
    }
    if (phaseTimer == 466){
        // remove mid reflector (which will be offscreen)
        with (objFinalP4MidReflector){
            instance_destroy();
        }
    }
    if (phaseTimer &gt;= 466 &amp;&amp; phaseTimer &lt;= 485){
        view_xview = lerp(dyingStoredViewValues[0], 0, sin((phaseTimer-465)/20 * pi/2));
        view_yview = lerp(dyingStoredViewValues[1], 608, sin((phaseTimer-465)/20 * pi/2));
        view_wview = lerp(dyingStoredViewValues[2], 800, sin((phaseTimer-465)/20 * pi/2));
        view_hview = lerp(dyingStoredViewValues[3], 608, sin((phaseTimer-465)/20 * pi/2));
        view_angle = lerp(dyingStoredViewValues[4], 0, sin((phaseTimer-465)/20 * pi/2));  // failsafe
    }
    if (phaseTimer == 466){
        var _tempArray;
        _tempArray[16, 3] = 0; //initialize array
        
        //x and y offsets
        _tempArray[0, 0] = -59;
        _tempArray[0, 1] = -55;
        _tempArray[1, 0] = +35;
        _tempArray[1, 1] = -50;
        _tempArray[2, 0] = -14;
        _tempArray[2, 1] = -25;
        _tempArray[3, 0] = -51;
        _tempArray[3, 1] = +41;
        _tempArray[4, 0] = -17;
        _tempArray[4, 1] = +60;
        _tempArray[5, 0] = +61;
        _tempArray[5, 1] = +22;
        _tempArray[6, 0] = -52;
        _tempArray[6, 1] = -5;
        _tempArray[7, 0] = -52;
        _tempArray[7, 1] = -31;
        _tempArray[8, 0] = +43;
        _tempArray[8, 1] = +48;
        _tempArray[9, 0] = +47;
        _tempArray[9, 1] = -3;
        _tempArray[10, 0] = -11;
        _tempArray[10, 1] = +31;
        _tempArray[11, 0] = -24;
        _tempArray[11, 1] = +47;
        _tempArray[12, 0] = -23;
        _tempArray[12, 1] = -19;
        _tempArray[13, 0] = -23;
        _tempArray[13, 1] = +6;
        _tempArray[14, 0] = +19;
        _tempArray[14, 1] = +41;
        _tempArray[15, 0] = +12;
        _tempArray[15, 1] = -21;
        _tempArray[16, 0] = +11;
        _tempArray[16, 1] = +7;
        
        //particle domain and range
        _tempArray[0, 2]  = 38;
        _tempArray[0, 3]  = 26;
        _tempArray[1, 2]  = 40;
        _tempArray[1, 3]  = 20;
        _tempArray[2, 2]  = 48;
        _tempArray[2, 3]  = 16;
        _tempArray[3, 2]  = 26;
        _tempArray[3, 3]  = 34;
        _tempArray[4, 2]  = 20;
        _tempArray[4, 3]  = 12;
        _tempArray[5, 2]  = 42;
        _tempArray[5, 3]  = 32;
        _tempArray[6, 2]  = 28;
        _tempArray[6, 3]  = 28;
        _tempArray[7, 2]  = 32;
        _tempArray[7, 3]  = 14;
        _tempArray[8, 2]  = 18;
        _tempArray[8, 3]  = 16;
        _tempArray[9, 2]  = 34;
        _tempArray[9, 3]  = 32;
        _tempArray[10, 2] = 38;
        _tempArray[10, 3] = 28;
        _tempArray[11, 2] = 12;
        _tempArray[11, 3] = 12;
        _tempArray[12, 2] = 22;
        _tempArray[12, 3] = 19;
        _tempArray[13, 2] = 30;
        _tempArray[13, 3] = 22;
        _tempArray[14, 2] = 22;
        _tempArray[14, 3] = 40;
        _tempArray[15, 2] = 36;
        _tempArray[15, 3] = 26;
        _tempArray[16, 2] = 26;
        _tempArray[16, 3] = 26;
        
        var _inst = -4;
        for (var i=0; i&lt;=16; i++){
            _inst = instance_create(x + _tempArray[i, 0]*image_xscale, y + _tempArray[i, 1]*image_yscale, objFinalP4ScribbleFragments);
            _inst.image_index = i;
            _inst.image_xscale = image_xscale;
            _inst.image_yscale = image_yscale;
            _inst.depth = depth;
            _inst.particleSpawnDomain = _tempArray[i, 2];
            _inst.particleSpawnRange  = _tempArray[i, 3];
        }
        audio_play_sound(sndFinalP4ScribbleBreak, 0, 0);
        
        with (objFakePlayer){
            var _inst = instance_create(x, y, objPlayer);
            scrCopyAspects(_inst);
            _inst.image_speed = 0;
            _inst.djump = djump;
            instance_destroy();
        }
        with (objFinalRNGDie){
            var _blockY = 1088;
            with (objBetterBlock){  // in case I change the block's y position
                if (y &gt; view_yview &amp;&amp; y &lt; room_height){
                    _blockY = y;
                }
            }
            var _inst;
            _inst = instance_create(x, y, objFinalBossEndDieDropped);
            _inst.sprite_index = sprite_index;
            _inst.image_index = image_index;
            
            if (other.buffDualAttacks){
                _inst.speed = 5;
                _inst.gravity = 0.235;
                _inst.direction = scrBallisticAngle(_inst.x, _inst.y, 400 + 160*part, _blockY, _inst.speed, _inst.gravity, 1);
                _inst.part = part;
            }
            
            instance_destroy();
        }
        visible = false;
    }
    if ((phaseTimer-466) mod 3 == 0){
        if (instance_exists(objFinalP4ScribbleFragments)){
            with (objFinalP4ScribbleFragments){
                with (objFinalP4PartCtrl){
                    delPartSpawnCoords[0] = other.x;
                    delPartSpawnCoords[1] = other.y;
                    delPartSpawnCoords[2] = other.particleSpawnDomain;
                    delPartSpawnCoords[3] = other.particleSpawnRange;
                    delPartsToCreate = irandom_range(10, 16);
                    event_user(1);
                }
            }
            
            _snd = audio_play_sound(sndFinalP4EditorDelete, 0, 0);
            audio_sound_pitch(_snd, PITCH_FLUCT);
            audio_sound_gain(_snd, 1.6 * (global.sfxLevel/100 * global.volumeLevel/100), 0);
        }
    }
}

if (erasable &gt;= 1){
    eraseShakePieceTimer ++;
    //generate new effects
    if (erasingHP &gt; 0 &amp;&amp; (eraseShakePieceTimer mod eraseShakePieceDelay) == 0){
        eraseShakePieceTarget = ceil(lerp(eraseShakePieceTargetMax, eraseShakePieceTargetInit, clamp(erasingHP/erasingHPInit, 0, 1)));
        
        var _interval = (eraseShakePieceTimer mod eraseShakePieceLifespan) div eraseShakePieceDelay; //0, 1, 2, 3
        if (_interval == 1){
            _interval = 2;
        }else if (_interval == 2){
            _interval = 1;
        }
        //0, 2, 1, 3
        
        var _number = (((eraseShakePieceTarget-1) - _interval) div eraseShakePieceBursts) + 1;
        var _spd = 0, _dir = 0, _offset = random(180)/_number; //the numbers in the _offset and _dir random functions must add up to 360
        for (var i = 0; i &lt; _number; i++){
            _dir = (360*i + random(180))/_number + _offset;
            _spd = random_range(0.6, 0.8) * (1 + 2*eraseShakePieceTarget/eraseShakePieceTargetMax);
            eraseShakeX[i*eraseShakePieceBursts + _interval] = 0;
            eraseShakeY[i*eraseShakePieceBursts + _interval] = 0;
            eraseShakeHspd[i*eraseShakePieceBursts + _interval] = _spd * dcos(_dir);
            eraseShakeVspd[i*eraseShakePieceBursts + _interval] = _spd * (-dsin(_dir));
            eraseShakeAlpha[i*eraseShakePieceBursts + _interval] = 1;
        }
    }
    //move effects
    for (var i=eraseShakePieceTarget-1; i &gt;= 0; i--){
        if (eraseShakeAlpha[i] &gt; 0){
            eraseShakeX[i] += eraseShakeHspd[i];
            eraseShakeY[i] += eraseShakeVspd[i];
            eraseShakeAlpha[i] -= 1/eraseShakePieceLifespan;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!started &amp;&amp; instance_exists(objPlayer)){
    with (objPlayer){
        if (place_meeting(x, y+2*global.grav, objBetterBlock)){
            // Autosave, then Transfer
            if (other.autosave &amp;&amp; !global.practicing){
                scrTMM_Autosave(400, 1040, 6);
                other.autosave = false;
            }
            scrFinalTransferHP(5, 4);
            
            other.started = true;
            scrFinalUpdateFarthest();
            
            other.phaseTimer = -30;
            with (objWorld){
                playIntro = true;
                playMusic = true;
                musicToPlay = global.BGMBoss4Main4;
            }
            
            if (!instance_exists(objFinalBossHP)){
                instance_create(0, 0, objFinalBossHP);
            }
            with (objFinalBossHP){
                descend = 1;
                currentHPVal = 5;
            }
        }
    }
}

if (started){
    var _movementTimerPrev;
    _movementTimerPrev = movementTimer;
    
    if (phase == 0){ //intro decent
        var _introLength = 212;
        if (!(global.dead &amp;&amp; ((introTimer+1) == 15 || (introTimer+1) == 45 || (introTimer+1) == 46 || (introTimer+1) == 113 || (introTimer+1) == 130 || (introTimer+1) == 148 || (introTimer+1) == 220 || (introTimer+1) == 265))){
            introTimer ++;
            if (introTimer == 15){
                instance_create(400, 576, objFinalP4MidReflector);
                //failsafe
                scrFinalUpdateFarthest();
            }else if (introTimer == 45 &amp;&amp; buffDualAttacks){
                with (objFinalRNGDie){
                    instance_destroy();
                }
                instance_create(400, 572, objFinalP4BuffDieBreak);
            }
            
            if (buffDualAttacks){
                // Initial decent
                if (introTimer &gt; 105 &amp;&amp; (introTimer-105) &lt;= 44){
                    y = lerp(ystart, destY, clamp(sin((introTimer-105)/44 * pi/2), 0, 1));
                    if ((introTimer-105) &gt;= 44){
                        yCent = y;
                    }
                    with (objMakerSpikeUp){  //used to hold RNG Die in the normal difficulty after Sudnep
                        instance_destroy();
                    }
                }
                
                // Grab RNG Die fragments on buffed difficulty
                if (introTimer &gt;= 130 &amp;&amp; instance_exists(objFinalP4BuffDieBreak)){  // die hasn't broken yet
                    if (objFinalP4BuffDieBreak.fade != -1){
                        introTimer = 130;
                    }
                }
                if (introTimer == 148){
                    with (objFinalRNGDie){
                        if (sprite_index == sprFinalBossRNGFragment){
                            event_user(0);
                            targetSpd = 0;  // smoother movement
                            
                            targetObj = other.id;
                            latchedOn = false;
                            
                            if (image_index == 0){
                                other.leftDiePiece = id;
                                appearYDiff = 0;  // reset after User Event 0
                            }else if (image_index == 1){
                                other.rightDiePiece = id;
                                appearYDiff = 0;  // reset after User Event 0
                            }
                        }
                    }
                }
                
                if (introTimer &gt;= _introLength){
                    var _dieLatchedOn = true;
                    with (objFinalRNGDie){
                        if (!latchedOn &amp;&amp; targetObj == other.id){
                            _dieLatchedOn = false;
                            break;
                        }
                    }
                    
                    if (_dieLatchedOn){
                        if (erasable == -1){
                            if (buffDualAttacks){
                                buffPhaseEndCount = 2;
                            }
                            event_user(1);
                        }else{
                            phase = -1; //allow player to erase
                            eraseSlowdown = 0;
                            erasable = 1;
                        }
                    }
                }
            }else{
                // Initial decent
                if (introTimer &gt; 45 &amp;&amp; (introTimer-45) &lt;= 68){
                    y = lerp(ystart, destY, clamp(sin((introTimer-45)/68 * pi/2), 0, 1));
                    if ((introTimer-45) &gt;= 68){
                        yCent = y;
                    }
                    with (objMakerSpikeUp){  //used to hold RNG Die in the normal difficulty after Sudnep
                        instance_destroy();
                    }
                }
                
                if (introTimer == 113){
                    // Grab RNG Die on normal difficulty
                    if (!buffDualAttacks){
                        if (!instance_exists(objFinalRNGDie)){
                            instance_create(x, y, objFinalRNGDie);
                        }
                        with (objFinalRNGDie){
                            targetObj = other.id;
                            latchedOn = true;
                            grow = true;
                            shrink = false;
                            appearYDiff = 108;
                        }
                    }
                }
                
                if (introTimer &gt;= 165){
                    if (erasable == -1){
                        event_user(1);
                    }else{
                        if (instance_exists(objFinalRNGDie) &amp;&amp; (objFinalRNGDie.targetObj == id || objFinalRNGDie.targetObj == object_index)){
                            phase = -1; //allow player to erase
                            eraseSlowdown = 0;
                            erasable = 1;
                        }
                    }
                }
            }
        }
        with (objFinalBossDraw){
            if (hitchBackBlendAmt &gt; 0){
                hitchBackDec = true;
            }
        }
    }else if (erasable == -1 &amp;&amp; ((!buffDualAttacks &amp;&amp; phase != -1) || (buffDualAttacks &amp;&amp; (leftPhaseIndex != -1 || rightPhaseIndex != -1)))){
        if (global.dead &amp;&amp; storeDeathAttack){
            global.scribbleP4LastDeath = phase;
        }
        if (initialAccel &lt; 1){
            initialAccel = min(initialAccel + 0.04, 1);
        }
        
        if (!buffDualAttacks){
            var _phasePrev = phase;
            scrFinalP4Attack();
            
            if (phase == -1){
                //track recent attacks for reshuffling
                for (var i=(prevPhasesToTrack-1); i&gt;=1; i-=1;){
                    phaseLast[i] = phaseLast[(i-1)];
                }
                phaseLast[0] = (_phasePrev);
                
                event_user(1);
            }
            if (instance_exists(objFinalRNGDie)){
                if (dieChangeState == 1){
                    objFinalRNGDie.grow = true;
                    objFinalRNGDie.shrink = false;
                    objFinalRNGDie.appearYDiff = 108;
                }else if (dieChangeState == -1){
                    objFinalRNGDie.grow = false;
                    objFinalRNGDie.shrink = true;
                }
                dieChangeState = 0;
            }
        }else{
            var _phasePrev;
            // First attack  --&gt;  Left Piece
            if (leftPhaseIndex != -1){
                phase = leftPhaseIndex;
                phaseTimer = leftPhaseTimer;
                spawnSide = leftSpawnSide;
                
                _phasePrev = phase;
                scrFinalP4Attack();
                
                leftSpawnSide = spawnSide;
                leftPhaseTimer = phaseTimer;
                leftPhaseIndex = phase;
                
                
                if (leftPhaseIndex == -1){
                    //track recent attacks for reshuffling
                    for (var i=(prevPhasesToTrack-1); i&gt;=1; i-=1;){
                        phaseLast[i] = phaseLast[(i-1)];
                    }
                    phaseLast[0] = (_phasePrev);
                    
                    event_user(1);
                }
                
                if (dieChangeState == 1){
                    with (leftDiePiece){
                        grow = true;
                        shrink = false;
                        if (latchedOn){
                            appearXDiff = 64*part;
                            appearYDiff = 108;
                        }
                    }
                }else if (dieChangeState == -1){
                    with (leftDiePiece){
                        shrink = true;
                        grow = false;
                    }
                }
                dieChangeState = 0;
            }
            
            // Second attack  --&gt;  Right Piece
            if (rightPhaseIndex != -1){
                phase = rightPhaseIndex;
                phaseTimer = rightPhaseTimer;
                spawnSide = rightSpawnSide;
                
                _phasePrev = phase;
                scrFinalP4Attack();
                
                rightSpawnSide = spawnSide;
                rightPhaseTimer = phaseTimer;
                rightPhaseIndex = phase;
                
                if (rightPhaseIndex == -1){
                    //track recent attacks for reshuffling
                    for (var i=(prevPhasesToTrack-1); i&gt;=1; i-=1;){
                        phaseLast[i] = phaseLast[(i-1)];
                    }
                    phaseLast[0] = (_phasePrev);
                    
                    event_user(1);
                }
                
                if (dieChangeState == 1){
                    with (rightDiePiece){
                        grow = true;
                        shrink = false;
                        if (latchedOn){
                            appearXDiff = 64*part;
                            appearYDiff = 108;
                        }
                    }
                }else if (dieChangeState == -1){
                    with (rightDiePiece){
                        shrink = true;
                        grow = false;
                    }
                }
                dieChangeState = 0;
            }
        }
    }else{
        if (eraseSlowdown &gt; 0){
            eraseSlowdown -= clamp(eraseSlowdown/10, 0.02, 0.07);
            if (eraseSlowdown &lt; 0){
                eraseSlowdown = 0;
                view_angle = 0;
            }else{
                if (view_angle != 0){
                    view_angle = lerp(0, eraseStartViewAng, eraseSlowdown);
                }
                movementTimer += eraseSlowdown;
            }
        }
    }
    
    //I'm trying to make some cool movement pattern here
    if (phase != 0 &amp;&amp; (erasable == -1 || eraseSlowdown &gt; 0)){
        if (erasable == -1){
            if (leftPhaseIndex == 7 || rightPhaseIndex == 7){
                movementTimer += (min(sqr(yoyoSpeed), 1) * initialAccel);
            }else{
                movementTimer += (1 * initialAccel);
            }
        }else if (eraseSlowdown &gt; 0){
            eraseSlowdown -= clamp(eraseSlowdown/10, 0.02, 0.07);
            if (eraseSlowdown &lt;= 0){
                eraseSlowdown = 0;
            }
            if (view_angle != 0){
                view_angle = lerp(0, eraseStartViewAng, eraseSlowdown);
            }
            movementTimer += eraseSlowdown * initialAccel;
        }
    }
    
    if (global.dead &amp;&amp; erasable == -1){
        yCentRise = min(yCentRise + 0.15, 7);
        yCent -= yCentRise;
    }
    if (movementTimer != _movementTimerPrev){
        var _input, _sign, _val;
        _input = movementTimer/40;
        _sign = sign(((_input+2) mod 4) - 2);
        if (_sign == 0){
            _sign = 1;
        }
        _val = power(abs(_input mod 2 - 1), 2.4);
        x = xCent + 40 * (_sign * (_val-1));
        
        _input = movementTimer/65;
        _sign = sign(((_input+2) mod 4) - 2);
        if (_sign == 0){
            _sign = 1;
        }
        _val = power(abs(_input mod 2 - 1), 2.65);
        y = yCent + 40 * (_sign * (_val-1));
    }
}

// manage visual effects  +  iframe generousity
event_inherited();
if (erasable &gt;= 0 &amp;&amp; dying){
    image_index = 1;  // overwrite the image_index set in the parent object's code
}

//detect if player is below screen (needed for Phase 5)
if (instance_exists(objPlayer)){
    var _halfWidth = 400;
    var _halfHeight = 304;
    var _halfDist = point_distance(_halfWidth, _halfHeight, objPlayer.x - view_xview[0], objPlayer.y - view_yview[0]);
    var _halfDir = point_direction(_halfWidth, _halfHeight, objPlayer.x - view_xview[0], objPlayer.y - view_yview[0])-view_angle[0];
    var _adjustX = _halfWidth + (-dcos(_halfDir)*_halfDist);
    var _adjustY = _halfHeight + (-dsin(_halfDir)*_halfDist);
    if (_adjustX &lt;= -5 || _adjustX &gt;= 806 || _adjustY &gt;= 608 + 12){
        scrKillPlayer();
    }
}

/*
//DEBUG
if (keyboard_check(vk_up)){
    view_angle = -22.5;
}else if (keyboard_check(vk_down)){
    view_angle = 22.5;
}*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objBullet">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var _hp;
_hp = scrFinalGetHP(currentHPVal);

if (_hp &gt; 0 &amp;&amp; erasable == -1 &amp;&amp; bbox_bottom &gt; 0 &amp;&amp; image_alpha &gt;= 1){
    if (iframes &gt; 0){
        if (iframes &lt;= iframesWhenHit/3){
            storedHit = true;
        }
    }else{
        scrFinalScribbleDamage();
        //update hp value
        _hp = scrFinalGetHP(currentHPVal);
        
        if (_hp &lt;= 0){
            if (!global.practicing || global.practiceWaypointEnd &gt; 9){
                event_user(2); //begin deletion section
            }else{
                scrPracticeEnd();
                phase = -1;
                leftPhaseIndex = -1;
                rightPhaseIndex = -1;
            }
        }
    }
    with (other){
        x = xprevious;
        y = yprevious;
        scrMoveContactObject(sign(hspeed), 0, abs(hspeed), other);
        scrMoveContactObject(0, sign(vspeed), abs(vspeed), other);
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlayer">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!dying){
    scrKillPlayer();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///select an attack from the randomly-selected attack array
var _attack = -1;
if (!global.practicing || practiceAttackNum &lt; 1){ //Normal behavior
    if (!buffDualAttacks &amp;&amp; !global.practicing &amp;&amp; phase == global.scribbleP4LastDeath){ //beat the last attack they died on
        storeDeathAttack = true; //store the next attack that kills the player
    }
    for (var i=0; i&lt;attackNum; i++){
        if (attack[i] == 0){
            _attack = i;
        }
        attack[i] --;
    }
}else{ //Selective practicing
    //the "voracious reader" system isn't used in practice mode
    if (practiceAttackIndex &lt; practiceAttackNum){
        _attack = practiceAttack[practiceAttackIndex];
        practiceAttackIndex ++;
    }
}

if (_attack == -1){ //all attacks have been used
    event_user(0);  //reshuffle order
    event_user(3);  //attempt to choose an attack (again)
}else{
    phase = (_attack+1);
    //show_debug_message("beginning attack " + string(_attack+1));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Begin deletion section
erasable = 0;
eraseStartViewAng = view_angle;
spawnSide = choose(-1, 1);
eraseSlowdown = 1; //not necessary
dieChangeState = 1;
alarm[0] = -1;
alarm[1] = erasableTransitionTime;
phaseTimer = -(erasableTransitionTime);

with (objFinalP4MidReflector){
    disabled = true;
}

with (all){
    switch(object_index){
        case objFinalP4LarryMagic:
        case objFinalP4KirbyProjs:
        case objFinalP4PatTear:
        case objFinalP4TralexSpawner:
        case objFinalP4TralexStar:
        case objFinalP4KurathSpike:
        case objFinalP4KurathSpikeShard:
        case objFinalP4DribixTorch:
        case objFinalP4DribixTorchProj:
        case objFinalKadyProj:
            expand = true;
        break;
        
        case objFinalKnightRocks:
        case objFinalKnightTHRounded:
            var _inst = instance_create(x, y, objFinalP4ProjFade);
            scrCopyAspects(_inst);
            _inst.image_speed = 0;
            _inst.indexBase = indexBase;
            instance_destroy();
        break;
        
        default:
            if (object_index == objMakerFruit || object_is_ancestor(object_index, objMakerFruit) || object_index == objMakerTHBullet || object_is_ancestor(object_index, objMakerTHBullet)){
                var _inst = instance_create(x, y, objFinalP4ProjFade);
                scrCopyAspects(_inst);
                _inst.image_speed = 0;
                _inst.indexBase = indexBase;
                instance_destroy();
            }
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// attempt to switch to next attack
if (!global.dead){
    //get the previously-selected phase (or phase)
    if (buffDualAttacks){
        buffPhaseEndCount ++;
        if (buffPhaseEndCount &gt;= 2){
            if (instance_exists(objFinalP4TralexStar)){  // not destroyed until both attacks end
                with (objFinalP4TralexStar){
                    expand = true;
                    speed = 0;
                    gravity = 0;
                }
                audio_sound_pitch(audio_play_sound(sndMakerSampleBlaster, 0, 0), 1.4);
            }
            
            event_user(3);
            rightPhaseIndex = phase;
            
            event_user(3);
            leftPhaseIndex = phase;
            
            //reset attack variables
            leftPhaseTimer = 0;
            rightPhaseTimer = 0;
            
            leftSpawnSide = choose(-1, 1);
            rightSpawnSide = -(leftSpawnSide);
            
            buffPhaseEndCount -= 2;
        }
    }else{
        event_user(3);
        //reset attack variables
        phaseTimer = 0;
        spawnSide = choose(-1, 1);
    }
}else{
    // We set the phase(s) to `-1` so the object will still hover
    if (buffDualAttacks){
        buffPhaseEndCount ++;
        if (buffPhaseEndCount &gt;= 2){
            phase = -1;
            rightPhaseIndex = -1;
        }
    }else{
        phase = -1; 
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///assign priority to each randomly-selected attack
var _index = 0, _failsafe = 0, _loopStart = 0, _counter = 0;

// mark all attacks as not set
for (var i=0; i&lt;attackNum; i++){
    attack[i] = -1;
}

//Ensure an attack won't repeat *too* quickly (not relevant for initial shuffle; only affects random attacks in practice mode)
var _minimumDelay; // must wait _ phases from the first reshuffled attack before giving any of these attacks again
if (buffDualAttacks){
    _minimumDelay = 2;  // (one pair)
}else{
    _minimumDelay = 3;
}

//Fill the attack array
var _attackChoices = 0;  //number of options to choose from when choosing a random attack
if (!global.practicing || practiceAttackNum &lt; 1){ //default behavior
    var _attackChoices = attackNum;
    
    //generate new values for recent attacks, using `_minimumDelay`
    if (phaseLast[0] &gt;= 0){  // not the first shuffle
        var _slot = 0, _totalSlots = (attackNum-_minimumDelay);
        for (var i=0; i&lt;prevPhasesToTrack; i++){
            show_debug_message("Minimum delay system attack " + string(i) + " is attack index " + string(phaseLast[i]));
            _slot = irandom(_totalSlots-1);
            prevPhaseNewIndex[i] = 0;
            
            if (i &gt; 0){
                _failsafe = 0;
                while (_slot &gt;= 0){
                    for (var j = 0; j &lt;= (i-1); j++){
                        if (prevPhaseNewIndex[i] == prevPhaseNewIndex[j]){
                            break;  // from the "for" loop
                        }
                        if (j == (i-1)){
                            _slot --;
                        }
                    }
                    if (_slot &gt;= 0){
                        prevPhaseNewIndex[i] = ((prevPhaseNewIndex[i] + 1) mod _totalSlots);
                    }
                    
                    _failsafe ++;
                    if (_failsafe &gt; (attackNum-1)){
                        show_debug_message('"minimum delay" system failsafe triggered after ' + string(_failsafe) + " filled slots");
                        i = prevPhasesToTrack;  // needed to exit "for" loop
                        break; // from the "for" *and* "while" loops
                    }
                }
            }else{  // all slots will be empty on first selection
                prevPhaseNewIndex[i] = _slot;
            }
        }
        
        for (var i=0; i&lt;prevPhasesToTrack; i++){
            if (phaseLast[i] &gt;= 0 &amp;&amp; phaseLast[i] &lt; attackNum &amp;&amp; prevPhaseNewIndex[i] &gt;= 0){  // failsafe
                attack[phaseLast[i]] = (prevPhaseNewIndex[i]  + _minimumDelay);
                show_debug_message("Min Delay:  Setting attack index " + string(phaseLast[i]) + " to slot " + string(attack[phaseLast[i]]));
                _attackChoices --;
            }
        }
    }
    
    //"voracious reader" system
    if (!global.practicing &amp;&amp; !buffDualAttacks &amp;&amp; global.scribbleP4LastDeath &gt;= 1 &amp;&amp; global.scribbleP4LastDeath &lt;= attackNum){
        attack[floor(global.scribbleP4LastDeath-1)] = 0; //ensure we start with this attack
        _loopStart = 1; //start assigning indexes from the second slot, since the first is taken
        global.scribbleP4LastDeath = -1;
        show_debug_message("Player previously died to attack " + string(global.scribbleP4LastDeath-1) + "; Set as first attack; Start assigning indexes from the second slot");
    }
    
    //shuffle remaining values
    show_debug_message("Random Shuffling: Attempting to fill " + string(_attackChoices) + " slots with random attacks");
    
    var _skippedPriorityOffset = 0;  // increments when an attack set by the "minimum delay" system is reahed
    var _alreadySet;
    for (var i = _loopStart; i &lt; attackNum; i++){  // `i` represents the "priority" we're gving each attack `_index`
        _alreadySet = false;
        if (phaseLast[0] &gt;= 0){
            for (var j = 0; (j &lt; prevPhasesToTrack &amp;&amp; !_alreadySet); j++){
                if ((phaseLast[j] &gt;= 0 &amp;&amp; phaseLast[j] &lt; attackNum) &amp;&amp; i == attack[phaseLast[j]]){
                    _alreadySet = true;
                    _skippedPriorityOffset ++;
                    show_debug_message("Skipping attack priority " + string(i) + ", which was already filled with attack index " + string(phaseLast[j]) + ' by the "minimum delay" system');
                    break;
                }
            }
        }
        if (_alreadySet){  // make sure not to give two attacks the same index
            continue;
        }
        
        _counter = irandom_range(1, ((_attackChoices + _skippedPriorityOffset) - i));
        show_debug_message("Attempting to give priority " + string(i) + " to free attack " + string(_counter));
        
        _failsafe = 0;
        _index = 0;
        while (_counter &gt;= 0){
            if (attack[_index] &lt; 0){
                _counter --;
                if (_counter &lt;= 0){
                    break;
                }
            }else{
                _failsafe ++;
            }
            _index = ((_index + 1) mod attackNum);
            
            if (_failsafe &gt; (attackNum+prevPhasesToTrack)){
                show_debug_message("Failsafe: Random attack array filled by value " + string(i) + "; `_index` is at " + string(_index));
                break;
            }
        }
        if (_failsafe &gt; attackNum){ //terminate the "for" loop early if we broke out of the "while" loop
            break;
        }
        attack[_index] = i;
    }
}else{ // Practice mode behavior
    // buffed attacks are paired
    if (buffDualAttacks &amp;&amp; (practiceAttackNum mod 2) == 1){
        practiceAttackNum = min(practiceAttackNum+1, attackNum);
    }
    practiceAttackIndex = 0;
    
    //add the "set" attacks
    for (var i=0; i&lt;practiceAttackNum; i++){
        if (global.practiceFinalBossVal[i] &gt; 0 &amp;&amp; global.practiceFinalBossVal[i] &lt;= attackNum){ //not random
            practiceAttack[i] = (global.practiceFinalBossVal[i]-1);
            attack[(global.practiceFinalBossVal[i]-1)] = 1; //used to control shuffling
        }
    }
    
    //calculate number of attacks *not* in the list set by the player
    //to clarify, the player can set the same attack in multiple positions, but when choosing a random attack, the game will not select one the player has already chosen at least once
    for (var i=0; i &lt; attackNum; i++){
        if (attack[i] == -1){
            _attackChoices ++;
        }
    }
    
    //fill in "?" slots with random attacks
    for (var i=0; i &lt; practiceAttackNum; i++){ //`i` represents the slot we're assigning an attack to
        if (!(global.practiceFinalBossVal[i] &gt; 0 &amp;&amp; global.practiceFinalBossVal[i] &lt;= attackNum)){ //only fill "random" slots
            _counter = irandom_range(1, _attackChoices); //what number slot in the "list" of choices to choose
            
            _failsafe = 0;
            _index = 0;
            while (_counter &gt; 0){
                if (attack[_index] &lt; 0){
                    _counter --;
                    if (_counter &lt;= 0){
                        break;
                    }
                }else{
                    _failsafe ++;
                }
                _index = (_index + 1) mod attackNum;
                
                if (_failsafe &gt; (attackNum+prevPhasesToTrack)){
                    show_debug_message("Failsafe: Random attack array filled by value " + string(i) + "; `_index` reached " + string(_index));
                    break;
                }
            }
            practiceAttack[i] = _index;
            attack[_index] = 1;
            _attackChoices --;
            //DON'T terminate the "for" loop early if we broke out of the "while" loop, as it's not necessary and will break things
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>xprevious = x;
yprevious = y;

var _transitionAlphaMult = 1;
if (erasable &gt;= 0){
    if (phaseTimer &gt;= 0){
        _transitionAlphaMult = 0;
    }else{
        _transitionAlphaMult = abs(phaseTimer)/erasableTransitionTime;
    }
    x += eraseXOff*(1-_transitionAlphaMult);
    y += eraseYOff*(1-_transitionAlphaMult);
}

if (_transitionAlphaMult == 1){
    // Inherit parent draw event
    event_inherited();
}else if (_transitionAlphaMult &gt; 0){
    for (var i=trailPieces-1; i&gt;=0; i--){
        draw_sprite_ext(facelessSprite, image_index - imgSpd*(i+1), trailX[i], trailY[i], trailScale[i]*(1 - i/trailPieceMax), trailScale[i]*(1 - i/trailPieceMax), 0, c_gray, 0.4 * sqr(_transitionAlphaMult));
    }
    
    var _backGlow;
    var _backAuraNum = 5;
    var _backAuraAlpha;
    for (var i=0; i&lt;_backAuraNum; i++){
        _backGlow = ((sin(auraGlowAng - 2*pi * i/4)/2 + 0.5) + auraGlowOffset * 0.2) * _transitionAlphaMult;
        draw_sprite_ext(sprMrScribbleFaceless, image_index, x, y, abs(image_xscale) * (1 + 0.25*_backGlow) + 0.6*(1-_transitionAlphaMult), abs(image_yscale) * (1 + 0.25*_backGlow) + 0.6*(1-_transitionAlphaMult), 0, image_blend, image_alpha * (0.1 + 0.2*_backGlow) * alphaMult * sqr(_transitionAlphaMult));
    }
    
    if (surface_exists(surf)){
        surface_set_target(surf);
        draw_clear_alpha(c_black, 0);
        for(var i=outlinePieces-1; i&gt;0; i--){
            draw_sprite_ext(sprMrScribbleFaceless, image_index, 256, 256, image_xscale + i/50, image_yscale + i/50, 0, image_blend, (1 - i/outlinePieces));
        }
        surface_reset_target();

        draw_surface_ext(surf, x - 256*(1 + 0.6*(1-_transitionAlphaMult)), y - 256*(1 + 0.6*(1-_transitionAlphaMult)), (1 + 0.6*(1-_transitionAlphaMult)), (1 + 0.6*(1-_transitionAlphaMult)), 0, c_white, image_alpha * alphaMult * _transitionAlphaMult);

        draw_sprite_ext(sprMrScribble, image_index, x, y, image_xscale, image_yscale, 0, image_blend, image_alpha * alphaMult);
    }
    if (global.finalGlowEnabled &amp;&amp; global.extraEffects){
        if (glowAlpha &gt; 0 &amp;&amp; surface_exists(glowSurf)){
            surface_set_target(glowSurf);
            draw_clear_alpha(c_black, 0);
            draw_sprite_ext(sprMrScribble, image_index, 256, 256, image_xscale, image_yscale, 0, image_blend, 1);
            surface_reset_target();

            if (surface_exists(glowSurf)){
                shader_set(shdFinalWhite);
                shader_set_uniform_f(global.finalGlowHandle, 512, 512, 10, glowAlpha*image_alpha*alphaMult*_transitionAlphaMult);
                draw_surface_ext(glowSurf, x - 256, y - 256, 1, 1, 0, c_white, 1);
                shader_reset();
            }
        }
    }
}else{
    if (!surface_exists(surf)){
        surf = surface_create(512, 512);
    }
    
    if (surface_exists(surf)){
        surface_set_target(surf);
        draw_clear_alpha(c_black, 0);
        
        //draw_set_colour_write_enable(true, true, true, false);  // draw color, but not alpha
        
        draw_sprite_ext(sprMrScribbleFaceless, image_index, 256, 256, 1, 1, 0, c_white, 1);
        if (eraseShakePieceTarget &gt;= 2){
            for (var i=eraseShakePieceTarget-1; i &gt;= 0; i--){
                if (eraseShakeAlpha[i] &gt; 0){
                    draw_sprite_ext(sprMrScribbleFaceless, image_index, 256 + eraseShakeX[i], 256 + eraseShakeY[i], 1, 1, 0, c_white, 0.4*eraseShakeAlpha[i]);
                }
            }
        }
        draw_sprite_ext(sprMrScribbleFace, image_index, 256, 256, 1, 1, 0, c_white, 1);
        
        draw_set_colour_write_enable(false, false, false, true);
        draw_sprite(sprMrScribble, image_index, 256, 256);
        
        draw_set_blend_mode(bm_subtract);
        draw_rectangle(0, 0, 512, 256-74 + min((155 + 5) * (1 - erasingHP/erasingHPInit) - 7, 155), false);
        
        var _topXOff = ((global.count*2) mod 72);
        for (var i=0; i&lt;5; i++;){
            draw_sprite(sprFinalP4DeletionTop, 0, (172 + 72*i) - _topXOff, 256-74 + min((155 + 5) * (1 - erasingHP/erasingHPInit) - 7, 155));
        }
        draw_set_blend_mode(bm_normal);
        draw_set_colour_write_enable(true, true, true, true);
        surface_reset_target();
        
        draw_surface_ext(surf, x - 256*image_xscale, y - 256*image_xscale, image_xscale, image_yscale, 0, c_white, 1);
        
        if (erasingHP &lt; erasingHPInit){
            surface_set_target(surf);
            draw_clear_alpha(c_black, 0);
            //draw color, but not alpha
            draw_set_colour_write_enable(true, true, true, false);
            
            draw_sprite_ext(sprMrScribbleFaceless, image_index, 256, 256, 1, 1, 0, c_ltgray, 1);
            if (eraseShakePieceTarget &gt;= 2){
                for (var i=eraseShakePieceTarget-1; i &gt;= 0; i--){
                    if (eraseShakeAlpha[i] &gt; 0){
                        draw_sprite_ext(sprMrScribbleFaceless, image_index, 256 + eraseShakeX[i], 256 + eraseShakeY[i], 1, 1, 0, c_ltgray, eraseShakeAlpha[i]/2);
                    }
                }
            }
            
            //draw alpha with bm_max blending
            draw_set_colour_write_enable(false, false, false, true);
            draw_sprite_ext(sprMrScribbleFaceless, image_index, 256, 256, 1, 1, 0, c_white, 1);
            
            draw_set_blend_mode(bm_subtract);
            draw_rectangle(0, 256-74 + min((155 + 5) * (1 - erasingHP/erasingHPInit) - 7, 155) + 8, 512, 512, false);
            
            for (var i=0; i&lt;5; i++){
                draw_sprite_ext(sprFinalP4DeletionTop, 0, (172 + 72*i - 36) - _topXOff, 256-74 + min((155 + 5) * (1 - erasingHP/erasingHPInit) - 7, 155) + 8, 1, -1, 0, c_white, 1);
            }
            draw_set_blend_mode(bm_normal);
            
            draw_set_colour_write_enable(true, true, true, true);
            surface_reset_target();
            
            draw_surface_ext(surf, x - 256*image_xscale, y - 256*image_xscale, image_xscale, image_yscale, 0, c_white, 1);
        }
    }
}
x = xprevious;
y = yprevious;

///See explanation in objFinalRNGDie's draw event
//if (instance_exists(objFinalBossChar_4)){
    /*with (objFinalRNGDiePart){
        draw_self();  // actually don't look at that explanation because this was removed lol
    }*/
//}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
