<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprCamera</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>10000</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (instance_number(object_index) &gt; 1){
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.dropshadows &amp;&amp; !instance_exists(objGeezerPacCtrl)){
    if (!surface_exists(global.sharedSurf3)){
        global.sharedSurf3 = surface_create(800, 608);
    }
    
    var _shadowDist = 3;
    var _xdiff = (-view_xview)  +  _shadowDist;
    if (_xdiff == 0){
        _xdiff = 0.1;  // patch fix for objects that need to check if their draw code is being called by objDropShadows
    }
    var _ydiff = (-view_yview)  +  _shadowDist;
    if (surface_exists(global.sharedSurf3)){
        surface_set_target(global.sharedSurf3);
        draw_clear_alpha(c_black, 0);
        
        draw_set_blend_mode_ext(bm_one, bm_inv_src_alpha);
        with (all){
            switch(object_index){
                case objDropShadows:
                case objGeneralDialogue:
                case objWater:
                case objWater2:
                    break;
                case objSettingsMenu:
                    draw_rectangle(24 + _shadowDist  +0.5, y+66 + _shadowDist  +0.5, 763 + _shadowDist  +0.5, y + 572 + _shadowDist  +0.5, false);
                    break;
                case objPopup:
                    draw_rectangle(160 + _shadowDist  +0.5, y - 74 + _shadowDist  +0.5, 639 + _shadowDist  +0.5, y+79 + _shadowDist  +0.5, false);
                    break;
                case objBackgroundManager:
                    if (room == rStage01Abstr4ktNew){
                        drawXOff = _xdiff;
                        drawYOff = _ydiff;
                        event_perform(ev_draw, 0);
                        drawXOff = 0;
                        drawYOff = 0;
                    }
                    break;
                case objBetterBlock:
                    if (!drawShadow){
                        break;
                    }
                case objDropShadowSquare:
                case objMiniBlock:
                    draw_sprite_ext(sprFinalTiles, 0, bbox_left + sprite_width/2  + _xdiff, bbox_top + sprite_height/2  + _ydiff, sprite_width/32, sprite_height/32, image_angle, c_black, 1);
                    break;
                case objFinalP1Tiles:
                case objFinalTilesAutomaticBlock:
                case objFinalTilesAutomaticNoblock:
                    draw_sprite_ext(sprFinalTiles, 0, x + _xdiff, y + _ydiff, image_xscale, image_yscale, image_angle, c_black, 1);
                    break;
                case objGeezerBoss:
                case objGeezerSurvival:
                    draw_sprite_ext(sprGeezerCase, 0, x  +_xdiff, y + _ydiff, 7, 7, 0, c_white, 1);
                    break;
                case objTilesToSurf:
                case objBackTilesToSurf:
                case objS1ZeusCloud:
                case objBeelzTimerDraw:
                case objChaozCutscene:
                case objChaozCtrl:
                case objS2Abstr4ktNewRainbow:
                case objS2FlappyCtrl:
                case objS2FlappyPipe:
                case objGeezerBlock:
                case objGeezerBlockMulti:
                case objS4CherrySine:
                case objFinalSudnepCtrl:
                case objClearLobbyDecor:
                case objClearLobbyMenus:
                    drawXOff = _xdiff;
                    drawYOff = _ydiff;
                    event_perform(ev_draw, 0);
                    drawXOff = 0;
                    drawYOff = 0;
                    break;
                case objPlayer:
                case objMakerInfoBox:
                case objSave:
                case objMakerBossSave:
                case objMakerBossSaveHard:
                case objMakerParachute:
                case objMakerPShield:
                case objMakerSpikeUp:
                case objMakerSpikeLeft:
                case objMakerSpikeRight:
                case objMakerSpikeDown:
                case objMakerMoveSpike:
                case objMakerCrusher:
                case objMakerTeleTransitionExit:
                case objMakerHeartProp:
                case objBeelzebubTiles:
                case objMakerPlayerSize:
                case objS2FlappyShip:  // needs drawXOff set to avoid drawing the up arrow
                case objGeezerMegaEye:
                case objGeezerPacGhost:
                case objGeezerLaser:
                case objTHKid:
                case objFinalLarry:
                case objFinalKnight:
                case objFinalKirby:
                case objFinalKirbySword:
                case objFinalKadyCtrl:
                case objFinalKurathSpider:
                case objFinalP2Leash:
                case objFinalPatCtrl:
                case objFinalPatTear:
                case objFinalP3Dribix:
                case objFinalP3DribixTorchBall:
                case objFinalTralexCane:
                case objFinalP4BackTiles:
                case objFinalP4KirbyProjs:
                case objFinalP4PatTear:
                case objFinalP4TralexSpawner:
                case objFinalP4DeletionProj:
                case objFinalP4KurathSpikeShard:
                case objMakerTriJumpStar:
                case objClearLobbyCtrl:
                    x += _xdiff;
                    y += _ydiff;
                    drawXOff = _xdiff;
                    drawYOff = _ydiff;
                    event_perform(ev_draw, 0);
                    drawXOff = 0;
                    drawYOff = 0;
                    x -= _xdiff;
                    y -= _ydiff;
                    break;
                case objMakerTrigger:
                case objBullet:
                case objBlockBroken:
                case objFakePlayer:
                case objExpandFade:
                case objMakerGroundProps:
                case objMakerGravFlip:
                case objMakerCoin:
                case objJumpRefresher:
                case objMakerWarp:
                case objMakerFruit:
                case objMakerKillBlock:
                case objMakerPlatform:
                case objMakerSpring:
                case objMakerTHBullet:
                case objGeneralNonkiller:
                case objMakerButton:
                case objMakerTeleporter:
                case objS1Abstr4ktNewOneWay:
                case objS1Abstr4ktFallPlatform:
                case objS1KillblockPart:
                case objS1ZeusLightning:
                case objBeelzP01a:
                case objS1_128ExpandBlock:
                case objS2FlappyButton:
                case objGeezerMegaMet:
                case objGeezerCursor:
                case objGeezerCursorPart:
                case objGeezerGoomba:
                case objGeezerVirus:
                case objGeezerVPart:
                case objGeezerStupidSpike:
                case objGeezerStupidProj:
                case objGeezerPacPower:
                case objGeezerSquare:
                //case objGeezerMegaExplosion:
                case objGeezerMadCannon:
                case objDropShadowSprite:
                case objFinalBossCutscene:
                case objFinalBossScribbleParent:  // don't give the glow a shadow
                case objFinalLarryMagicSpawner:
                case objFinalLarryCoin:
                case objFinalKnightFirework:
                case objFinalKnightGun:
                case objFinalKnightWarning:
                case objFinalP2Exclamation:
                case objFinalKurath:
                case objFinalKurathPvZSpike:
                case objFinalKurathFruit:
                case objFinalYoyo:
                case objFinalYoyoLaser:
                case objFinalP3DribixBall:
                case objFinalP3DribixBallBig:
                case objFinalP3DribixSpike:
                case objFinalTralexBlaster:
                case objFinalTralexShockwave:
                case objFinalSudnepObject_1:
                case objFinalSudnepObject_2:
                case objFinalP4DribixTorch:
                case objFinalP4DribixTorchProj:
                case objFinalP4KurathSpike:
                case objFinalP4ProjFade:
                    if (visible &amp;&amp; sprite_index &gt;= 0){
                        x += _xdiff;
                        y += _ydiff;
                        draw_self();
                        x -= _xdiff;
                        y -= _ydiff;
                    }
                    break;
                // different sprite for dropshadow
                case objMakerBubble:
                case objMakerBubbleToggle:
                    var _shadowSpr = -4;
                    switch(sprite_index){
                        case sprMakerBubble:
                            _shadowSpr = sprMakerBubbleShadow;
                            break;
                        case sprMakerBubbleStart:
                            _shadowSpr = sprMakerBubbleStartShadow;
                            break;
                        case sprMakerBubbleEnd:
                            _shadowSpr = sprMakerBubbleEndShadow;
                            break;
                    }
                    if (visible &amp;&amp; _shadowSpr &gt;= 0){
                        x += _xdiff;
                        y += _ydiff;
                        draw_sprite_ext(_shadowSpr, image_index, x, y, image_xscale, image_yscale, image_angle, c_white, image_alpha);
                        x -= _xdiff;
                        y -= _ydiff;
                    }
                    break;
                // special cases
                case objFinalBossCutsceneDie:
                case objFinalRNGDie:
                    x += _xdiff;
                    y += _ydiff;
                    event_user(1);
                    x -= _xdiff;
                    y -= _ydiff;
                    break;
                case objCreditsCtrl:
                    drawXOff = _xdiff;
                    drawYOff = _ydiff;
                    
                    draw_rectangle(0, 0, 800, 64-0.5  + drawYOff, false);  // top
                    draw_rectangle(0, 544-0.5  + drawXOff, 800, 608, false);  // bottom
                    draw_rectangle(0, 64-0.5, 64-0.5  + drawXOff, 544-0.5, false);  // left
                    draw_rectangle(736-0.5  + drawXOff, 64-0.5, 800, 544-0.5, false);  // right
                    
                    for (var i=3; i&lt;22; i++){
                        draw_sprite_ext(sprMakerSpike, image_index, (32*i + 16) + drawXOff,  80 + drawYOff, image_xscale, -1, 0, c_white, image_alpha);
                        draw_sprite_ext(sprMakerSpike, image_index, (32*i + 16) + drawXOff, 528 + drawYOff, image_xscale, 1, 0, c_white, image_alpha);
                    }
                    for (var j=3; j&lt;16; j++){
                        draw_sprite_ext(sprMakerSpike, image_index,  80 + drawXOff, (32*j + 16) + drawYOff, image_xscale, -1, 90, c_white, image_alpha);
                        draw_sprite_ext(sprMakerSpike, image_index, 720 + drawXOff, (32*j + 16) + drawYOff, image_xscale, 1, 90, c_white, image_alpha);
                    }
                    drawXOff = 0;
                    drawYOff = 0;
                    break;
                case objTHCtrl:
                    drawXOff = _xdiff;
                    drawYOff = _ydiff;
                    event_user(3);
                    drawXOff = 0;
                    drawYOff = 0;
                    break;
                default: //parents
                    if (object_is_ancestor(object_index, objMakerFruit) || object_is_ancestor(object_index, objMakerTHBullet) || object_is_ancestor(object_index, objMakerKillBlock) || object_is_ancestor(object_index, objMakerPlatform)){
                        if (visible &amp;&amp; image_alpha &gt;= 0 &amp;&amp; sprite_index &gt;= 0){
                            x += _xdiff;
                            y += _ydiff;
                            draw_self();
                            x -= _xdiff;
                            y -= _ydiff;
                        }
                    }else if (object_is_ancestor(object_index, objMakerSpikeUp)){
                        if (visible &amp;&amp; image_alpha &gt;= 0){
                            x += _xdiff;
                            y += _ydiff;
                            event_perform(ev_draw, 0);
                            x -= _xdiff;
                            y -= _ydiff;
                        }
                    }
                    break;
            }
        }
        draw_set_blend_mode(bm_normal);
        
        if (room == rStage01Dice){
            draw_background(tlMakerTree, 656 + _xdiff, 128 + _ydiff);
        }
        // objTilesToSurf will not run for these rooms, since they are too big for some computers
        // rGeezer01 isn't big, but it doesn't have tiles and this is more efficient than having each Geezer block sprite draw itself
        // rFinalBoss_2 and rFinalBoss_4 are big as well, but they don't have any tiles
        if ((room == rStage04New_1 || room == rStage04New_2 || room == rStage04New_3 || room == rStage04New_4) || room == rTMM_ClearLobby){
            with (objBlock){  // draw shadows for tiles without using objTilesToSurf
                if (solid &amp;&amp; (bbox_left &gt;= 0 &amp;&amp; bbox_right &lt; room_width &amp;&amp; bbox_bottom &gt;= 0 &amp;&amp; bbox_top &lt; room_height)){  // solid = not a BetterBlock or platform
                    draw_rectangle(bbox_left + _xdiff, bbox_top + _ydiff, bbox_right + _xdiff, bbox_bottom + _ydiff, false);
                }
            }
        }
        surface_reset_target();
        
        if (global.extraEffects &amp;&amp; _shadowDist != 1){  // draw the shadow surface multiple times
            if (!surface_exists(global.sharedSurf2)){
                global.sharedSurf2 = surface_create(800, 608);
            }
            if (surface_exists(global.sharedSurf2)){
                surface_set_target(global.sharedSurf2);
                draw_clear_alpha(c_black, 0);
                if (surface_exists(global.sharedSurf3)){
                    for (var i=0; i&lt;_shadowDist; i++){
                        draw_surface(global.sharedSurf3, -i, -i);
                    }
                }
                surface_reset_target();
                
                if (surface_exists(global.sharedSurf2)){
                    draw_surface_ext(global.sharedSurf2, view_xview, view_yview, 1, 1, 0, c_black, 0.5);
                }else if (surface_exists(global.sharedSurf3)){
                    draw_surface_ext(global.sharedSurf3, view_xview, view_yview, 1, 1, 0, c_black, 0.5);
                }
            }
        }else{  // only draw the shadow surface once
            draw_surface_ext(global.sharedSurf3, view_xview, view_yview, 1, 1, 0, c_black, 0.5);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
