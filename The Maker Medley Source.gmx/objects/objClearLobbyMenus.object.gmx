<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprMakerMegaBlocks</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>12</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>drawXOff = 0;
drawYOff = 0;

//  MENUS  \\
font = fDefault12;
dropdownCol = make_color_rgb(163, 173, 196);
mainBoxCol = make_color_rgb(190, 200, 224);
selectedBoxCol =  make_color_rgb(228, 240, 242);
selectedTextCol = make_color_rgb(0, 110, 152);
scrollbarBackCol = make_color_rgb(63, 67, 117);
boxShadowCol = make_color_rgb(56, 96, 161);  // 62.7
mainRowRectCol = mainBoxCol;
submenuRowBackCol = make_color_rgb(195, 213, 238);
submenuRowRectCol = make_color_rgb(175, 201, 236);
ltgray = make_color_rgb(218, 227, 242);
makerPanelSep = make_color_rgb(114, 129, 164);
dkgray = make_color_rgb(16, 30, 41);
textOutlineCol = make_color_rgb(73, 74, 120);
selectedMenu = -1;  // 1 = game list; 2 = music;
clickedMenu = -1;  // 1 = game list; 2 = music;

//  RECORD  \\


//  ORIGINAL MAKERS  \\
makerMenuWidth = 432;
makerMenuHeight = 256;
makerMenuX = (800-makerMenuWidth)/2;
makerMenuY = 94;

makerPanelNum = 6;
makerPanelCur = 0;
makerPanelPrev = 0;
makerPanelDrawing = 0;
makerPanelTo = makerPanelCur;
makerPanelTransSpeed = 0;

makerPanelName[(makerPanelNum-1)] = 0;
makerPanelSlots[(makerPanelNum-1)] = 0;
makerCircleCol = make_color_rgb(114, 129, 164);
makerCircleOutCol = make_color_rgb(63, 67, 117);
// Arrows
makerPanelLeftSubimg = 3;
makerPanelRightSubimg = 0;
makerPanelLeftClicked = false;
makerPanelRightClicked = false;
//  END  ORIGINAL MAKERS  \\


//  MUSIC  \\
currentSong = 9;  // Stage 3 Hub
selectedMusicRow = -1;
selectedMusicSubmenu = -1;
clickedMusicRow = -1;
clickedMusicSubmenu = -1;

musicDropdownOpen = true;
musicDropdownLerp = 1;

songCount = 23;
songList[(songCount-1)] = -1;

// Dropdown Part Dimensions \\
draw_set_font(font);
buffer = 6;
musicMenuWidth = (32 + string_width(scrGetMusInfo(global.BGMBoss4Avo3, 0) + " - " + scrGetMusInfo(global.BGMBoss4Avo3, 2)) + 2*buffer);  // longest text (+ buffer)
musicDropdownSubmenuHeight = 19;
musicDropdownRowHeight = ((string_height("M") + 2) + buffer);
musicMenuHeightMin = 32;
musicMenuLeft = ceil((800 - musicMenuWidth)/2);
musicMenuTop = 56;
// END  Dropdown Part Dimensions \\

// Submenus (music dropdown) \\
submenuNum = 4;
submenuStart[(submenuNum-1)] = -1;
submenuEnd[(submenuNum-1)]   = -1;
submenuHeader[(submenuNum-1)] = "";
submenuOpen[(submenuNum-1)]  = false;
submenuLerpVal[(submenuNum-1)]  = 0;
submenuHeightMax[(submenuNum-1)]  = 0;
submenuHeightCurrent[(submenuNum-1)]  = 0;

// END Submenus \\

//  Dropdown Dimensions  \\
musicDropdownSubmenuHeight = sprite_get_height(sprClearDropdownSubmenu);
musicDropdownSubmenuArrowFrames = sprite_get_number(sprClearDropdownSubmenuArrow);
musicDropdownTopY = (musicDropdownRowHeight*currentSong);
musicDropdownHeightShown = 0;
musicDropdownHeightCurrent = (musicDropdownSubmenuHeight*submenuNum + musicDropdownRowHeight*(submenuEnd[2] - submenuStart[2]) + musicMenuHeightMin + buffer);
musicDropdownHeightExpanded = (musicDropdownRowHeight*songCount + musicDropdownSubmenuHeight*submenuNum + musicMenuHeightMin + buffer);
musicDropdownShownHeightCap = 400;
//  END Dropdown Dimensions  \\

//  Scrolling  \\
musicDropdownScrollYPos = 0;
musicDropdownScrollYAmt = 0;

musicDropdownScrollbarSelected = 0;
musicDropdownScrollbarState = 0; //0 = not clicked; 1 = drag the bar; 2 = move towards the cursor
musicDropdownScrollbarY = 0;
musicDropdownScrollbarWidth = 17;
musicDropdownScrollbarHeight = 0;
musicDropdownScrollClickYOff = 0;
musicDropdownScrollbarWidthShown = 0;
//  END Scrolling  \\

//  END MUSIC  \\


event_user(0);  // Fill in menu information
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var _screenX = 0, _screenY = 0;
if (instance_exists(objMakerCamera)){
    _screenX = objMakerCamera.xTo;
    _screenY = objMakerCamera.yTo;
}
var _currentMenu = 0;

var _playedSelectSFX = false;
var _playedClickSFX = false;
var _makerMenu = 1, _musicMenu = 2, _challengeMenu = 3;

//  MAKER PANEL  \\
if (view_xview &lt; 800 &amp;&amp; view_yview &gt;= 608){  // bottom-left screen
    _currentMenu = _makerMenu;
}
//  MUSIC DROPDOWN  \\
if (view_xview &gt; 800 &amp;&amp; view_yview &gt;= 608){  // bottom-right screen
    _currentMenu = _musicMenu;
}
//  CHALLENGE DROPDOWN  \\
if (view_xview == 800 &amp;&amp; view_yview &lt; 608){  // top-center screen
    _currentMenu = _challengeMenu;
}

// Interacting w/ Maker panel arrows
if (_currentMenu == _makerMenu){
    //store previous button state
    var _leftClickedPrev = makerPanelLeftClicked;
    var _rightClickedPrev = makerPanelRightClicked;
    
    // reset buttons if LMB is released
    if (!mouse_check_button(mb_left)){
        makerPanelLeftClicked = false;
        makerPanelRightClicked = false;
    }
    
    // Left Arrow
    if (makerPanelTo &gt; 0){
        mask_index = sprClearPanelCycleArrow;
        x = makerMenuX - (24 + 6*2);
        y = 608 + (makerMenuY + makerMenuHeight/2);
        image_xscale = 2;
        image_yscale = 2;
        if (collision_point(mouse_x, mouse_y, id, true, false) != noone){
            if (makerPanelLeftSubimg == 0){
                audio_stop_sound(sndMakerMenuSelect);
                audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
            }
            
            if (makerPanelLeftClicked){
                makerPanelLeftSubimg = 2;
            }else{
                makerPanelLeftSubimg = 1;
            }
        }else{
            makerPanelLeftSubimg = 0;
        }
        x = 0;
        y = 0;
        image_xscale = 1;
        image_yscale = 1;
        mask_index = -1;
    }else{
        makerPanelLeftSubimg = 3;  // unusable
    }
    
    
    // Right Arrow
    if (makerPanelTo &lt; (makerPanelNum-1)){
        mask_index = sprClearPanelCycleArrow;
        x = (makerMenuX + makerMenuWidth) + (24 + 6*2);
        y = 608 + (makerMenuY + makerMenuHeight/2);
        image_xscale = -2;
        image_yscale = 2;
        if (collision_point(mouse_x, mouse_y, id, true, false) != noone){
            if (makerPanelRightSubimg == 0){
                audio_stop_sound(sndMakerMenuSelect);
                audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
            }
            
            if (makerPanelRightClicked){
                makerPanelRightSubimg = 2;
            }else{
                makerPanelRightSubimg = 1;
            }
        }else{
            if (!mouse_check_button(mb_left)){
                makerPanelRightSubimg = 0;
            }
        }
        x = 0;
        y = 0;
        image_xscale = 1;
        image_yscale = 1;
        mask_index = -1;
    }else{
        makerPanelRightSubimg = 3;  // unusable
    }
    
    if (mouse_check_button_pressed(mb_left)){
        if (makerPanelLeftSubimg == 1){
            makerPanelLeftSubimg = 2;
            makerPanelLeftClicked = true;
        }else if (makerPanelRightSubimg == 1){
            makerPanelRightSubimg = 2;
            makerPanelRightClicked = true;
        }
    }
    
    if (mouse_check_button_released(mb_left)){
        var _makerPanelTo_prev = makerPanelTo;
        if (_leftClickedPrev &amp;&amp; makerPanelLeftSubimg == 1){  // clicked and selected
            makerPanelTo = max((makerPanelTo - 1), 0);
        }else if (_rightClickedPrev &amp;&amp; makerPanelRightSubimg == 1){  // clicked and selected
            makerPanelTo = min((makerPanelTo + 1), (makerPanelNum-1));
        }
        
        if (makerPanelTo != _makerPanelTo_prev &amp;&amp; makerPanelCur == _makerPanelTo_prev){  // not currently moving, but will be
            audio_stop_sound(sndMakerMenuClick);
            audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);
            var _snd = audio_play_sound(sndMakerSampleSwitch, 0, 0);
            audio_sound_pitch(_snd, 0.72);
        }
    }
}

// Interacting w/ Music menu
if (_currentMenu == _musicMenu){
    var _selectedRowPrev = selectedMusicRow, _selectedSubmenuPrev = selectedMusicSubmenu;
    selectedMusicRow = -1;
    selectedMusicSubmenu = -1;
    
    if (mouse_check_button_pressed(mb_right) &amp;&amp; musicDropdownOpen){
        musicDropdownOpen = false;
        clickedMenu = -1;
        if (!_playedClickSFX){audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);_playedClickSFX = true;}
    }else if (scrMouseInRange(musicMenuLeft, musicMenuTop, musicMenuLeft + musicMenuWidth + (musicDropdownScrollbarWidth*musicDropdownScrollbarWidthShown), musicMenuTop + musicMenuHeightMin, true)){
        if (selectedMenu != _musicMenu){
            selectedMenu = _musicMenu;
            if (!_playedSelectSFX &amp;&amp; !mouse_check_button_pressed(mb_left)){audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);_playedSelectSFX = true;}
        }
        
        if (clickedMenu != _musicMenu &amp;&amp; mouse_check_button_pressed(mb_left)){
            clickedMenu = _musicMenu;
        }
        
        if (clickedMenu == _musicMenu &amp;&amp; selectedMenu == clickedMenu &amp;&amp; mouse_check_button_released(mb_left)){
            clickedMenu = -1;
            musicDropdownOpen = !musicDropdownOpen;
            if (!_playedClickSFX){audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);_playedClickSFX = true;}
        }
    }else{
        selectedMenu = -1;
    }
}

// Menu + Submenu  opening/closing  animations
if (musicDropdownOpen){
    if (musicDropdownLerp &lt; 1){
        musicDropdownLerp = min(musicDropdownLerp + 0.0667, 1);
    }
}else{
    if (musicDropdownLerp &gt; 0){
        musicDropdownLerp = max(musicDropdownLerp - 0.0667, 0);
    }
}
for (var i=0; i&lt;submenuNum; i++){
    if (submenuOpen[i]){
        if (submenuLerpVal[i] &lt; 1){
            submenuLerpVal[i] = min(submenuLerpVal[i] + 0.0667, 1);
        }
    }else{
        if (submenuLerpVal[i] &gt; 0){
            submenuLerpVal[i] = max(submenuLerpVal[i] - 0.0667, 0);
        }
    }
    submenuHeightCurrent[i] = (submenuHeightMax[i] * scrEaseInOut(submenuLerpVal[i], 2.4));
}

// Get music dropdown height   (should happen even if menu is closed and/or offscreen)
musicDropdownHeightCurrent = 0;  // reset value
var _submenuCheck = 0;
for (var i=0; i&lt;songCount; i++){
    if ((_submenuCheck &gt;= 0 &amp;&amp; _submenuCheck &lt; submenuNum) &amp;&amp; i &gt;= submenuStart[_submenuCheck]){
        musicDropdownHeightCurrent += (submenuHeightCurrent[_submenuCheck] + musicDropdownSubmenuHeight);
        i = (submenuEnd[_submenuCheck]);
        _submenuCheck ++;
        continue;
    }else{
        musicDropdownHeightCurrent += musicDropdownRowHeight;
    }
}

if (musicDropdownLerp == 0){
    musicDropdownHeightShown = 0;
}else if (musicDropdownLerp == 1){
    musicDropdownHeightShown = min(musicDropdownHeightCurrent, musicDropdownShownHeightCap);
}else{
    musicDropdownHeightShown = min(musicDropdownHeightCurrent * scrEaseInOut(musicDropdownLerp, 2.4), musicDropdownShownHeightCap);
}

// Scrollbar values
var _musicScrollbar = (musicDropdownHeightCurrent &gt;= musicDropdownShownHeightCap);
if (_musicScrollbar){
    musicDropdownScrollbarWidthShown = min(musicDropdownScrollbarWidthShown + 0.1, 1);
    musicDropdownScrollbarHeight = (musicDropdownShownHeightCap / max(musicDropdownHeightCurrent/musicDropdownShownHeightCap, 1));
}else{
    musicDropdownScrollbarWidthShown = max(musicDropdownScrollbarWidthShown - 0.1, 0);
    musicDropdownScrollYAmt = 0;
}

// Interacting w/ Music menu elements
if (_currentMenu == _musicMenu){
    
    //  SCROLLING  \\
    if (musicDropdownOpen &amp;&amp; mouse_check_button_pressed(mb_right)){
        musicDropdownOpen = !musicDropdownOpen;
        audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);
    }
    
    if (_musicScrollbar){
        if (musicDropdownScrollbarState == 0){
            if (mouse_wheel_up() &amp;&amp; mouse_wheel_down()){
                //Do nothing. How/Why would you do this?
            }else if (mouse_wheel_up()){
                if (musicDropdownScrollYAmt &lt; 30){
                    musicDropdownScrollYAmt = 30;
                }else if (musicDropdownScrollYAmt &lt; 45){
                    musicDropdownScrollYAmt = min(musicDropdownScrollYAmt + 7, 45);
                }
            }else if (mouse_wheel_down()){
                if (musicDropdownScrollYAmt &gt; -30){
                    musicDropdownScrollYAmt = -30;
                }else if (musicDropdownScrollYAmt &gt; -45){
                    musicDropdownScrollYAmt = max(musicDropdownScrollYAmt - 7, -45);
                }
            }
        }
        
        //dragging scrollbar
        if (scrMouseInRange(musicMenuLeft + musicMenuWidth, (musicMenuTop + musicMenuHeightMin), musicMenuLeft + (musicMenuWidth + (musicDropdownScrollbarWidth*musicDropdownScrollbarWidthShown)), (musicMenuTop + musicMenuHeightMin) + musicDropdownHeightShown, true) || musicDropdownScrollbarState == 2){
            if (mouse_check_button(mb_left)){
                var _mouseYRelative = (mouse_y - (608+musicMenuTop));
                var _scrollbarEdge = 3;
                
                //normal scrolling
                if (musicDropdownScrollbarState == 0 &amp;&amp; mouse_check_button_pressed(mb_left)){
                    if (_mouseYRelative == median(musicDropdownScrollbarY, _mouseYRelative, musicDropdownScrollbarY + musicDropdownScrollbarHeight)){
                        musicDropdownScrollbarState = 1;
                        musicDropdownScrollClickYOff = musicDropdownScrollbarY - _mouseYRelative;
                    }else{
                        musicDropdownScrollbarState = 2;
                    }
                    if (!_playedClickSFX){audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);_playedClickSFX = true;}
                }
                
                if (musicDropdownScrollbarState == 1){
                    musicDropdownScrollbarY = _mouseYRelative + musicDropdownScrollClickYOff;
                }else if (musicDropdownScrollbarState == 2){
                    if (_mouseYRelative &lt; musicDropdownScrollbarY + _scrollbarEdge){
                        musicDropdownScrollbarY = max(_mouseYRelative - _scrollbarEdge, musicDropdownScrollbarY - 5);
                    }else if (_mouseYRelative &gt;= (musicDropdownScrollbarY + _scrollbarEdge) + musicDropdownScrollbarHeight){
                        musicDropdownScrollbarY = min((_mouseYRelative - _scrollbarEdge) - (musicDropdownScrollbarHeight), musicDropdownScrollbarY + 5);
                    }
                }
                
                musicDropdownScrollbarY = clamp(musicDropdownScrollbarY, 0, (musicDropdownShownHeightCap - musicDropdownScrollbarHeight));
                musicDropdownScrollYPos = lerp(0, musicDropdownHeightCurrent, musicDropdownScrollbarY/(musicDropdownShownHeightCap-musicDropdownScrollbarHeight));
                musicDropdownScrollYAmt = 0;
            }
            if (musicDropdownScrollbarSelected == 0){
                musicDropdownScrollbarSelected = 1;
                if (!_playedSelectSFX){audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);_playedSelectSFX = true;}
            }
        }else{
            musicDropdownScrollbarSelected = 0;
        }
        
        //Scroll if necessary
        if (musicDropdownScrollYAmt != 0){
            musicDropdownScrollYPos -= (musicDropdownScrollYAmt/4);
            if (abs(musicDropdownScrollYAmt) &lt; 4){
                musicDropdownScrollYAmt = 0;
            }else{
                musicDropdownScrollYAmt -= 5*sign(musicDropdownScrollYAmt);
            }
        }
    }else{
        musicDropdownScrollbarSelected = 0;
        musicDropdownScrollClickYOff = 0;
    }
    
    var _scrollMax = (musicDropdownHeightCurrent - musicDropdownShownHeightCap);
    musicDropdownScrollbarY = clamp(musicDropdownScrollbarY, 0, (musicDropdownShownHeightCap - musicDropdownScrollbarHeight));
    musicDropdownScrollYPos = lerp(0, _scrollMax, musicDropdownScrollbarY/(musicDropdownShownHeightCap - musicDropdownScrollbarHeight));
    //  END SCROLLING  \\
    
    
    //  SELECTING DROPDOWN ITEMS  \\
    if (musicDropdownOpen &amp;&amp; musicDropdownLerp &gt; 0){
        if (scrMouseInRange(musicMenuLeft, musicMenuTop + musicMenuHeightMin, musicMenuLeft + musicMenuWidth, (musicMenuTop + musicMenuHeightMin) + musicDropdownHeightShown, true)){
            /*if (mouse_y &lt; (musicMenuTop + musicMenuHeightMin)){
                selectedMusicRow = currentSong;
                musicDropdownSelectionType = "dropdown";
            }*/
            var _listY = 0;
            if (_musicScrollbar){
                _listY = roundSane(-musicDropdownScrollYPos);
            }
            var _submenuCur = 0;
            var _submenuStartHeight = 0;
            for (var i=0; (i&lt;songCount &amp;&amp; _listY &lt; musicDropdownShownHeightCap); i++){
                //submenu stuff
                if (_submenuCur &gt;= 0 &amp;&amp; _submenuCur &lt; submenuNum){
                    if (i &gt; submenuEnd[_submenuCur]){
                        _submenuCur ++;
                    }
                    if (_submenuCur &lt; submenuNum){  // ensure _submenuCur is still in range after above conditional
                        if (i == submenuStart[_submenuCur]){
                            if ((_listY + musicDropdownSubmenuHeight) &gt;= 0){
                                if (scrMouseInRange(musicMenuLeft, max(_listY, 0) + (musicMenuTop + musicMenuHeightMin), musicMenuLeft + musicMenuWidth, max(_listY + musicDropdownSubmenuHeight, 0) + (musicMenuTop + musicMenuHeightMin), true)){
                                    selectedMusicSubmenu = _submenuCur;
                                    if ((!_playedSelectSFX &amp;&amp; _selectedSubmenuPrev != _submenuCur)){
                                        if (!mouse_check_button_pressed(mb_left)){
                                            audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
                                            _playedSelectSFX = true;
                                        }
                                        show_debug_message("Selecting Submenu " + string(selectedMusicSubmenu));
                                    }
                                    
                                    if (clickedMusicSubmenu != _submenuCur &amp;&amp; mouse_check_button_pressed(mb_left)){
                                        clickedMusicSubmenu = _submenuCur;
                                    }
                                    if (clickedMusicSubmenu == selectedMusicSubmenu &amp;&amp; mouse_check_button_released(mb_left)){
                                        clickedMusicSubmenu = -1;
                                        submenuOpen[_submenuCur] = !submenuOpen[_submenuCur];
                                        if (!_playedClickSFX){audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);_playedClickSFX = true;}
                                    }
                                }
                            }
                            
                            _listY += musicDropdownSubmenuHeight;
                            _submenuStartHeight = _listY;
                            
                            if (submenuLerpVal[_submenuCur] &lt;= 0){  // no need to check any rows if the submenu is closed
                                i = (submenuEnd[_submenuCur]);
                                continue;
                            }
                        }
                        
                        //Account for dropdown submenu lerping
                        if (i &gt;= submenuStart[_submenuCur] &amp;&amp; (_listY + musicDropdownRowHeight) &gt;= (_submenuStartHeight + submenuHeightCurrent[_submenuCur])){
                            //Check if the mouse is over the shown part of this list
                            if ((_listY + musicDropdownRowHeight) &gt;= 0){
                                if (scrMouseInRange(musicMenuLeft, max(_listY, 0) + (musicMenuTop + musicMenuHeightMin), musicMenuLeft + musicMenuWidth, max(_submenuStartHeight + submenuHeightCurrent[_submenuCur], 0) + (musicMenuTop + musicMenuHeightMin), true)){
                                    selectedMusicRow = i;
                                    if (!_playedSelectSFX &amp;&amp; _selectedRowPrev != selectedMusicRow){
                                        audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
                                        _playedSelectSFX = true;
                                        show_debug_message("Selecting Song " + string(selectedMusicRow));
                                    }
                                    
                                    if (clickedMusicRow != i &amp;&amp; mouse_check_button_pressed(mb_left)){
                                        clickedMusicRow = i;
                                    }
                                    if (clickedMusicRow == selectedMusicRow &amp;&amp; mouse_check_button_released(mb_left)){
                                        clickedMusicRow = -1;
                                        currentSong = i;
                                        if (!_playedClickSFX){audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);_playedClickSFX = true;}
                                    }
                                }
                            }
                            
                            _listY = (_submenuStartHeight + submenuHeightCurrent[_submenuCur]);
                            i = (submenuEnd[_submenuCur]);
                            continue;
                        }
                    }
                }
                
                //selecting song
                if ((_listY + musicDropdownRowHeight) &gt;= 0 &amp;&amp; _listY &lt; musicDropdownHeightShown){  // Don't check the row if it is completely out of view
                    if (scrMouseInRange(musicMenuLeft, max(_listY, 0) + (musicMenuTop + musicMenuHeightMin), musicMenuLeft + musicMenuWidth, max(_listY + musicDropdownRowHeight, 0) + (musicMenuTop + musicMenuHeightMin), true)){
                        selectedMusicRow = i;
                        if (!_playedSelectSFX &amp;&amp; _selectedRowPrev != i){
                            audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
                            _playedSelectSFX = true;
                            show_debug_message("Selecting Song " + string(selectedMusicRow));
                        }
                        
                        if (clickedMusicRow != selectedMusicRow &amp;&amp; mouse_check_button_pressed(mb_left)){
                            clickedMusicRow = selectedMusicRow;
                        }
                        if (clickedMusicRow == selectedMusicRow &amp;&amp; mouse_check_button_released(mb_left)){
                            currentSong = clickedMusicRow;
                            clickedMusicRow = -1;
                            if (!_playedClickSFX){audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);_playedClickSFX = true;}
                        }
                    }
                }
                
                //End submenu list early if the rest is cut off
                //Note: since the menu is drawn from top to bottom, any overflow from this row will be overwritten and/or cropped out
                if (_submenuCur &lt; submenuNum){  // ensure _submenuCur is still in range after early conditional
                    if (i &gt;= submenuStart[_submenuCur] &amp;&amp; (_listY + musicDropdownRowHeight) &gt;= (_submenuStartHeight + submenuHeightCurrent[_submenuCur])){
                        _listY = (_submenuStartHeight + submenuHeightCurrent[_submenuCur]);
                        i = (submenuEnd[_submenuCur]);
                        continue;
                    }
                }
                
                _listY += musicDropdownRowHeight;
            }
        }
    }
    //  END SELECTING DROPDOWN ITEMS  \\
}else{  // not on screen
    //clear selection/clicked values
    selectedMenu = -1;
    selectedMusicRow = -1;
    selectedMusicSubmenu = -1;
    musicDropdownScrollbarState = 0; //0 = not clicked
}
with (objWorld){
    musicToPlay = other.songList[other.currentSong];
}

// [Will happen regardless of screen position]
// Maker Panel transition
if (makerPanelCur != makerPanelTo){
    var _transDir = sign(makerPanelTo - makerPanelCur);
    var _limit = clamp(abs(makerPanelTo-makerPanelCur)/3, 0.02, 0.20);
    makerPanelTransSpeed = clamp(makerPanelTransSpeed + 0.025*_transDir, -_limit, _limit);
    
    makerPanelCur += makerPanelTransSpeed;
    // play click sound when switching to/past new panel
    if (sign((makerPanelTo - makerPanelCur) - 0.01*_transDir) != _transDir){  // at or past destination (slight leniency for rounding errors)
        makerPanelCur = makerPanelTo;
    }
    if (floor(makerPanelCur + 0.01*_transDir) != floor((makerPanelCur + 0.01*_transDir) - makerPanelTransSpeed)){
        var _snd = audio_play_sound(sndMakerSampleSwitch, 0, 0);
        audio_sound_pitch(_snd, 1.312);
    }
}

//Reset click values if the left mouse button is not being held
if (!mouse_check_button(mb_left) &amp;&amp; !mouse_check_button_pressed(mb_left)){
    //Music dropdown
    clickedMenu = -1;
    clickedMusicRow = -1;
    clickedMusicSubmenu = -1;
    musicDropdownScrollbarState = 0; //0 = not clicked
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///maker panel -&gt; global.sharedSurf
if (!surface_exists(global.sharedSurf)){
    global.sharedSurf = surface_create(800, 608);
}

if (surface_exists(global.sharedSurf)){
    surface_set_target(global.sharedSurf);
    draw_clear_alpha(ltgray, 1);  // background color
    
    //Draw main panel
    draw_set_color(c_black);
    draw_set_valign(fa_middle);
    draw_set_halign(fa_left);
    draw_set_font(font);
    var _textX, _topTextY, _spacingY;
    _textX = 8;
    _topTextY = 58;
    _spacingY = 26;
    if (makerPanelDrawing == 5){
        _spacingY += 13;
    }
    for (var i=0; i&lt;makerPanelSlots[makerPanelDrawing]; i++){
        scrDrawTextOutlineMinimal(_textX, _topTextY + _spacingY*i, makerPanelLevel[makerPanelDrawing, i], c_white, c_black);
    }
    if (makerPanelDrawing == 3){  // Geezer hitchcock
        var _t = string_width("Avoidance-");
        draw_set_font(fIdentifierJPCH);
        scrDrawTextOutline((_textX  +  _t), (_topTextY + _spacingY*2) -3, "ヒッチコック", c_white, c_black);
        draw_set_font(font);
    }
    
    draw_set_halign(fa_right);
    _textX = makerMenuWidth - 14;
    if (makerPanelDrawing == 5){
        _topTextY += _spacingY/2;
    }
    for (var i=0; i&lt;makerPanelSlots[makerPanelDrawing]; i++){
        scrDrawTextOutlineMinimal(_textX, _topTextY + _spacingY*i, makerPanelMaker[makerPanelDrawing, i], c_white, c_black);
    }
    
    //title
    draw_set_halign(fa_center);
    draw_set_font(fFlappyCounter);
    draw_text_transformed_outline(makerMenuWidth/2, 20, makerPanelName[makerPanelDrawing], 3, c_black, 12, 0.5, 0.5, 0);
    
    //separation (used for the panning transition
    draw_set_color(makerPanelSep);
    var _borderWidth = 8;  // width of sprMakerSettingsBorder
    draw_sprite_stretched(sprMakerSettingsBorder, 8, makerMenuWidth, 0, _borderWidth, makerMenuHeight);
    
    draw_set_color(c_white);
    surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Menu information
// This takes up a bunch of space, so I'm moving it here
// Yes, I could use a separate "Execute Code" block, but it's too easy to move those around

//  MAKERS  \\
makerPanelName[0] = "Stage 1: Royalty-Free Safe Space";
makerPanelName[1] = "Boss 1: " + scrGetRoomInfo(rChaozB, 0);
makerPanelName[2] = "Stage 2: Not Another NANG Clone";
makerPanelName[3] = "Boss 2: " + scrGetRoomInfo(rGeezer01, 0);
makerPanelName[4] = "Stage 3: Knockoff Rush";
makerPanelName[5] = "The Elephant Crew";

makerPanelSlots[0] = 8;
makerPanelSlots[1] = 6;
makerPanelSlots[2] = 8;
makerPanelSlots[3] = 5;
makerPanelSlots[4] = 3;
makerPanelSlots[5] = 5;  // each slot has 2 makers

//initialize text arrays
for (var i=0; i&lt;makerPanelNum; i++){
    makerPanelLevel[i, makerPanelSlots[i]] = 0;
    makerPanelMaker[i, makerPanelSlots[i]] = 0;
}

// Stage 1
makerPanelLevel[0, 0] = scrGetRoomInfo(rStage01Abstr4ktNew, 0);
makerPanelMaker[0, 0] = scrGetRoomInfo(rStage01Abstr4ktNew, 1);
makerPanelLevel[0, 1] = scrGetRoomInfo(rStage01Dice, 0);
makerPanelMaker[0, 1] = scrGetRoomInfo(rStage01Dice, 1);
makerPanelLevel[0, 2] = scrGetRoomInfo(rStage01Kurath, 0);
makerPanelMaker[0, 2] = scrGetRoomInfo(rStage01Kurath, 1);
makerPanelLevel[0, 3] = scrGetRoomInfo(rStage01Zilily, 0);
makerPanelMaker[0, 3] = scrGetRoomInfo(rStage01Zilily, 1);
makerPanelLevel[0, 4] = scrGetRoomInfo(rStage01Purify, 0);
makerPanelMaker[0, 4] = scrGetRoomInfo(rStage01Purify, 1);
makerPanelLevel[0, 5] = scrGetRoomInfo(rStage01Onetwentyeight, 0);
makerPanelMaker[0, 5] = scrGetRoomInfo(rStage01Onetwentyeight, 1);
makerPanelLevel[0, 6] = scrGetRoomInfo(rStage01Patrick, 0);
makerPanelMaker[0, 6] = scrGetRoomInfo(rStage01Patrick, 1);
makerPanelLevel[0, 7] = scrGetRoomInfo(rStage01Ace, 0);
makerPanelMaker[0, 7] = scrGetRoomInfo(rStage01Ace, 1);

// Boss 1
for (var i=0; i&lt;makerPanelSlots[1]; i++){
    makerPanelLevel[1, i] = scrGetAttackInfo(rChaozB, i, 0);
    makerPanelMaker[1, i] = scrGetAttackInfo(rChaozB, i, 1);
}

// Stage 2
makerPanelLevel[2, 0] = scrGetRoomInfo(rStage02Shark1, 0);
makerPanelMaker[2, 0] = scrGetRoomInfo(rStage02Shark1, 1);
makerPanelLevel[2, 1] = scrGetRoomInfo(rStage02Shark2, 0);
makerPanelMaker[2, 1] = scrGetRoomInfo(rStage02Shark2, 1);
makerPanelLevel[2, 2] = scrGetRoomInfo(rStage02Erik, 0);
makerPanelMaker[2, 2] = scrGetRoomInfo(rStage02Erik, 1);
makerPanelLevel[2, 3] = scrGetRoomInfo(rStage02Klamy, 0);
makerPanelMaker[2, 3] = scrGetRoomInfo(rStage02Klamy, 1);
makerPanelLevel[2, 4] = scrGetRoomInfo(rStage02Abstr4ktNew, 0);
makerPanelMaker[2, 4] = scrGetRoomInfo(rStage02Abstr4ktNew, 1);
makerPanelLevel[2, 5] = scrGetRoomInfo(rStage02Vovka, 0);
makerPanelMaker[2, 5] = scrGetRoomInfo(rStage02Vovka, 1);
makerPanelLevel[2, 6] = scrGetRoomInfo(rStage02Telejump, 0);
makerPanelMaker[2, 6] = scrGetRoomInfo(rStage02Telejump, 1);
makerPanelLevel[2, 7] = scrGetRoomInfo(rStage02Flappy, 0);
makerPanelMaker[2, 7] = scrGetRoomInfo(rStage02Flappy, 1);

// Boss 2
for (var i=0; i&lt;makerPanelSlots[3]; i++){
    makerPanelLevel[3, i] = scrGetAttackInfo(rGeezer01, i, 0);
    makerPanelMaker[3, i] = scrGetAttackInfo(rGeezer01, i, 1);
}

// Knockoff Rush
makerPanelLevel[4, 0] = scrGetRoomInfo(rStage03PvZ, 0);
makerPanelMaker[4, 0] = scrGetRoomInfo(rStage03PvZ, 1);
makerPanelLevel[4, 1] = scrGetRoomInfo(rStage03Undertale, 0);
makerPanelMaker[4, 1] = scrGetRoomInfo(rStage03Undertale, 1);
makerPanelLevel[4, 2] = scrGetRoomInfo(rStage03Touhou, 0);
makerPanelMaker[4, 2] = scrGetRoomInfo(rStage03Touhou, 1);

for (var i=0; i&lt;makerPanelSlots[3]; i++){
    makerPanelLevel[5, i] = scrGetAttackInfo(rFinalBoss_1, (2*i), 1);
    makerPanelMaker[5, i] = scrGetAttackInfo(rFinalBoss_1, ((2*i)+1), 1);
}

//  END MAKERS  \\

//  MUSIC  \\
songList[0] = global.BGMTitle;
songList[1] = global.BGMStage1a;
songList[2] = global.BGMStage1b;
songList[3] = global.BGMBoss1;
songList[4] = global.BGMStage2a;
songList[5] = global.BGMStage2b;
songList[6] = global.BGMBoss2a;
songList[7] = global.BGMBoss2b;
songList[8] = global.BGMBoss2c;
songList[9] = global.BGMStage3Hub;
songList[10] = global.BGMStage3a;
songList[11] = global.BGMStage3b;
songList[12] = global.BGMStage3c;
songList[13] = global.BGMStage3c2;
songList[14] = global.BGMStage4;
songList[15] = global.BGMBoss4Main;
songList[16] = global.BGMBoss4Avo1;
songList[17] = global.BGMBoss4Main2;
songList[18] = global.BGMBoss4Avo2;
songList[19] = global.BGMBoss4Main3;
songList[20] = global.BGMBoss4Avo3;
songList[21] = global.BGMBoss4Main4;
songList[22] = global.BGMCredits;

//First entry in submenu
submenuStart[0] = 1;
submenuStart[1] = 4;
submenuStart[2] = 9;
submenuStart[3] = 14;

// Last entry in submenu
submenuEnd[0] = 3;
submenuEnd[1] = 8;
submenuEnd[2] = 13;
submenuEnd[3] = 21;

submenuHeader[0] = "Royalty-Free Safe Space";
submenuHeader[1] = "Not Another NANG Clone";
submenuHeader[2] = "Knockoff Rush";
submenuHeader[3] = "Fractured Flashbacks";

for (var i=0; i&lt;submenuNum; i++){
    submenuOpen[i] = false;
    submenuLerpVal[i] = 0;
    submenuHeightMax[i] = ((submenuEnd[i] - submenuStart[i]) + 1) * musicDropdownRowHeight;
    submenuHeightCurrent[i]  = 0;
}

//Index 2 should start open, because it contains the default song
submenuOpen[2] = true;
submenuLerpVal[2] = 1;
submenuHeightCurrent[2] = submenuHeightMax[2];
//  END MUSIC  \\
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var _borderWidth = 8;

if (drawXOff == 0){
    draw_set_font(font);
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
    
    //Menus
    var _currentMenu = 0;
    var _makerMenu = 1, _musicMenu = 2, _challengeMenu = 3;
    
    //  MAKER PANEL  \\
    if (view_xview &lt; 800 &amp;&amp; view_yview &gt;= 608){  // bottom-left screen
        _currentMenu = _makerMenu;
    }
    //  MUSIC DROPDOWN  \\
    if (view_xview &gt; 800 &amp;&amp; view_yview &gt;= 608){  // bottom-right screen
        _currentMenu = _musicMenu;
    }
    //  CHALLENGE DROPDOWN  \\
    if (view_xview == 800 &amp;&amp; view_yview &lt; 608){  // top-center screen
        _currentMenu = _challengeMenu;
    }

    if (_currentMenu == _makerMenu){
        var _borderWidth = 8;
        //Coordinates
        var _left = (0 + makerMenuX);
        var _right = (_left + makerMenuWidth);
        var _top = (608 + makerMenuY);
        var _bottom = (_top + makerMenuHeight);
        var _crop = (makerPanelCur - floor(makerPanelCur));
        draw_rectangle(_left  +0.5, _top  +0.5, _right  -0.5, _bottom  -0.5, false);
        
        // Draw panel (or panels during transition)
        var _panelFullWidth = (makerMenuWidth+_borderWidth);
        makerPanelDrawing = floor(makerPanelCur);
        event_user(1);  // maker panel -&gt; global.sharedSurf
        if (surface_exists(global.sharedSurf)){
            var _width = (_panelFullWidth * _crop);
            draw_surface_part(global.sharedSurf, _width, 0, min((_panelFullWidth - _width), makerMenuWidth), makerMenuHeight, _left, _top);
        }
        if (makerPanelCur != floor(makerPanelCur)){  // right (during transition)
            makerPanelDrawing = ceil(makerPanelCur);
            event_user(1);  // maker panel -&gt; global.sharedSurf
            if (surface_exists(global.sharedSurf)){
                var _xPos = (_panelFullWidth * (1-_crop));
                if (_xPos &lt; makerMenuWidth){  // some part of the surface will be drawn
                    draw_surface_part(global.sharedSurf, 0, 0, (makerMenuWidth - _xPos), makerMenuHeight, _left + _xPos, _top);
                }
            }
        }
        
        //Border Edges
        draw_sprite_ext(sprMakerSettingsBorder, 0, _left, (_top-_borderWidth), (makerMenuWidth/_borderWidth), 1, 0, c_white, 1);    // top
        draw_sprite_ext(sprMakerSettingsBorder, 0, _left, (_bottom+_borderWidth), (makerMenuWidth/_borderWidth), -1, 0, c_white, 1);   // bottom
        draw_sprite_ext(sprMakerSettingsBorder, 1, (_left-_borderWidth), _top, 1, (makerMenuHeight/_borderWidth), 0, c_white, 1);    // left
        draw_sprite_ext(sprMakerSettingsBorder, 1, (_right+_borderWidth), _top, -1, (makerMenuHeight/_borderWidth), 0, c_white, 1);    //right
        
        //Border Corners
        draw_sprite_ext(sprMakerSettingsBorder, 2, (_left-_borderWidth), (_top-_borderWidth), 1, 1, 0, c_white, 1);     // TL
        draw_sprite_ext(sprMakerSettingsBorder, 2, (_left-_borderWidth), (_bottom+_borderWidth), 1, 1, 90, c_white, 1);     // BL
        draw_sprite_ext(sprMakerSettingsBorder, 2, (_right+_borderWidth), (_top-_borderWidth), 1, 1, 270, c_white, 1);    // TR
        draw_sprite_ext(sprMakerSettingsBorder, 2, (_right+_borderWidth), (_bottom+_borderWidth), 1, 1, 180, c_white, 1);    // BR
        
        //Arrows
        draw_sprite_ext(sprClearPanelCycleArrow, makerPanelLeftSubimg, makerMenuX - (24 + 6*2), 608 + (makerMenuY + makerMenuHeight/2), 2, 2, 0, c_white, 1);
        draw_sprite_ext(sprClearPanelCycleArrow, 4 + makerPanelRightSubimg, (makerMenuX + makerMenuWidth) + (24 + 6*2), 608 + (makerMenuY + makerMenuHeight/2), 2, 2, 0, c_white, 1);
    }else if (_currentMenu == _musicMenu){
        var _borderWidth = 3;
        //Get value used for linear intepolation when the menu is appearing or disappearing
        var _lerpVal = 0;
        if (musicDropdownLerp == 0 || musicDropdownLerp == 1){
            _lerpVal = musicDropdownLerp;
        }else{
            if (musicDropdownLerp &lt; 0.5){
                _lerpVal = power(2, (2.4 - 1)) * power(musicDropdownLerp, 2.4);
            }else{
                _lerpVal = 1 - (power(2 * (1-musicDropdownLerp), 2.4)/2);
            }
            _lerpVal = scrEaseInOut(musicDropdownLerp, 2.4);
        }
        
        // Draw dropdown list, if necessary
        var _musicScrollbar = (musicDropdownHeightCurrent &gt; musicDropdownShownHeightCap);
        if (musicDropdownLerp &gt; 0){
            // Calculate values
            var _songEdgeLeft = 2;
            var _songEdgeWidth = sprite_get_width(sprClearDropdownRounded);
            var _songRectMainX1 = (_songEdgeLeft + _songEdgeWidth);
            var _songRectMainX2 = (musicMenuWidth - _songRectMainX1);
            var _songTextLeft = (_songEdgeLeft + 4);
            var _submenuEdgeWidth = sprite_get_width(sprClearDropdownSubmenu);
            var _submenuMainXoff = (_submenuEdgeWidth - 2);
            var _submenuStartHeight = 0;
            var _submenuArrowX = (musicMenuWidth-16);
            var _inSubmenu = false;
            
            if (!surface_exists(global.sharedSurf)){
                global.sharedSurf = surface_create(800, 608);
            }
            
            if (surface_exists(global.sharedSurf)){
                surface_set_target(global.sharedSurf);
                draw_clear_alpha(c_black, 0);
                
                draw_set_color(c_black);
                draw_set_halign(fa_left);
                draw_set_valign(fa_top);
                
                var _listY = 0;
                if (_musicScrollbar){
                    _listY = roundSane(-musicDropdownScrollYPos);
                }
                var _submenuCur = 0;
                for (var i=0; (i&lt;songCount &amp;&amp; _listY &lt; musicDropdownShownHeightCap); i++){
                    //submenu stuff
                    if (_submenuCur &gt;= 0 &amp;&amp; _submenuCur &lt; submenuNum){
                        if (i &gt; submenuEnd[_submenuCur]){
                            _inSubmenu = false;
                            _submenuCur ++;
                        }
                        if (_submenuCur &lt; submenuNum){  // ensure _submenuCur is still in range after above conditional
                            if (i == submenuStart[_submenuCur]){
                                _inSubmenu = true;
                                var _interactionSubimageBase = 0;
                                if (selectedMusicSubmenu == _submenuCur){
                                    if (clickedMusicSubmenu == selectedMusicSubmenu){
                                        _interactionSubimageBase = 2*3;
                                    }else{
                                        _interactionSubimageBase = 1*3;
                                    }
                                }
                                
                                if (_listY &gt; -musicDropdownRowHeight &amp;&amp; _listY &lt; musicDropdownHeightShown){  // don't draw if it won't appear on the screen
                                    draw_sprite(sprClearDropdownSubmenu, _interactionSubimageBase+0, 0, _listY);
                                    draw_sprite_stretched(sprClearDropdownSubmenu, _interactionSubimageBase+1, _submenuMainXoff, _listY, (musicMenuWidth - 2*_submenuMainXoff), musicDropdownSubmenuHeight);
                                    draw_sprite(sprClearDropdownSubmenu, _interactionSubimageBase+2, (musicMenuWidth - _submenuMainXoff), _listY);
                                    
                                    var _arrowFrame = (submenuLerpVal[_submenuCur] * (musicDropdownSubmenuArrowFrames-1));
                                    draw_sprite_ext(sprClearDropdownSubmenuArrow, floor(_arrowFrame), _submenuArrowX, _listY + (musicDropdownSubmenuHeight/2), 1, 1, -90*submenuLerpVal[_submenuCur], c_white, 1);
                                    if (_arrowFrame != floor(_arrowFrame)){draw_sprite_ext(sprClearDropdownSubmenuArrow, ceil(_arrowFrame), _submenuArrowX, _listY + (musicDropdownSubmenuHeight/2), 1, 1, -90*submenuLerpVal[_submenuCur], c_white, (_arrowFrame mod 1));}
                                    
                                    scrDrawTextOutlineMinimal((_borderWidth + 3), _listY + 3, submenuHeader[_submenuCur], c_white, textOutlineCol);
                                }
                                _listY += musicDropdownSubmenuHeight;
                                _submenuStartHeight = _listY;
                                
                                if (submenuLerpVal[_submenuCur] &lt;= 0){  // no need to check any rows if the submenu is closed
                                    i = (submenuEnd[_submenuCur]);
                                    continue;
                                }
                            }
                        }
                    }
                    
                    //Main rows
                    if ((_listY + musicDropdownRowHeight) &gt;= 0 &amp;&amp; _listY &lt; musicDropdownHeightShown){  // don't draw the row if it won't appear on the screen
                        // I draw a new rectangle for every row so if part of an earlier row "overflows" when a submenu is expanding, it will be covered up by the row below it
                        var _rectEdgeOffset = 0;
                        if (_inSubmenu){
                            draw_set_color(submenuRowBackCol);
                            _rectEdgeOffset = 2;
                        }else{
                            draw_set_color(ltgray);
                            _rectEdgeOffset = 0;
                        }
                        draw_rectangle(- 0.5, _listY  + 0.5, musicMenuWidth  - 0.5, _listY + (musicDropdownRowHeight)  - 0.5, false);
                        draw_set_color(c_white);
                        
                        draw_sprite(sprClearDropdownRounded, (_rectEdgeOffset+0), _songEdgeLeft, (_listY + (buffer/2)));
                        draw_sprite(sprClearDropdownRounded, (_rectEdgeOffset+1), musicMenuWidth - (_songEdgeLeft + _songEdgeWidth + 2), (_listY + (buffer/2)));
                        
                        if (_inSubmenu){
                            draw_set_color(submenuRowRectCol);
                        }else{
                            draw_set_color(mainRowRectCol);
                        }
                        draw_rectangle(_songRectMainX1  - 0.5, (_listY + (buffer/2))  + 0.5, _songRectMainX2  - 0.5, ((_listY + (buffer/2)) + (musicDropdownRowHeight - buffer)), false);
                        
                        if (i == selectedMusicRow){
                            draw_set_color(c_white);
                            draw_set_colour_write_enable(1, 1, 1, 0);
                            
                            draw_set_alpha(0.56 + 0.24*(0.5 + sin(global.count * pi/80)/2));
                            draw_rectangle(- 0.5, _listY  + 0.5, musicMenuWidth  - 0.5, (_listY + musicDropdownRowHeight)  - 0.5, false);
                            draw_set_alpha(1);
                            
                            draw_set_colour_write_enable(1, 1, 1, 1);
                        }
                        
                        draw_set_color(c_black);
                        draw_text(_songTextLeft, round(_listY + buffer), scrGetMusInfo(songList[i], 0) + " - " + scrGetMusInfo(songList[i], 2));  // Song name and description
                        draw_set_color(c_white);
                    }
                    
                    //End submenu list early if the rest is cut off
                    if (_submenuCur &gt;= 0 &amp;&amp; _submenuCur &lt; submenuNum){
                        //Note: since the menu is drawn from top to bottom, any overflow from this row will be overwritten and/or cropped out
                        if (i &gt;= submenuStart[_submenuCur] &amp;&amp; (_listY + musicDropdownRowHeight) &gt;= (_submenuStartHeight + submenuHeightCurrent[_submenuCur])){
                            _listY = roundSane(_submenuStartHeight + submenuHeightCurrent[_submenuCur]);
                            i = (submenuEnd[_submenuCur]);
                            continue;
                        }
                    }
                    
                    _listY += musicDropdownRowHeight;
                }
                
                //Scroll bar
                if (musicDropdownScrollbarWidthShown &gt; 0){
                    var _top, _bottom, _left, _right;
                    _top = 0;
                    _bottom = musicDropdownHeightShown;
                    _left = musicMenuWidth;
                    _right = (_left + (musicDropdownScrollbarWidth*musicDropdownScrollbarWidthShown));
                    //Container
                    draw_set_color(scrollbarBackCol);
                    draw_rectangle(_left, _top, _right, _bottom, false);
                    draw_set_color(c_black);
                    draw_rectangle((_left-1), _top, _right, _bottom, true);
                    draw_rectangle(_left, _top, (_right-1), _bottom, true);
                    draw_set_color(c_white);
                    
                    //Bar
                    var _scrollInd;
                    if (musicDropdownScrollbarState != 0){
                        _scrollInd = 2;
                    }else if (musicDropdownScrollbarSelected != 0){
                        _scrollInd = 1;
                    }else{
                        _scrollInd = 0;
                    }
                    
                    draw_sprite(sprMakerTitleScrollbar, _scrollInd*3, _left, ((_top + 1) + musicDropdownScrollbarY));
                    draw_sprite_stretched(sprMakerTitleScrollbar, _scrollInd*3 + 1, _left, (_top + 8) + musicDropdownScrollbarY, 16, (musicDropdownScrollbarHeight - 16));
                    draw_sprite(sprMakerTitleScrollbar, _scrollInd*3 + 2, _left, (_top + musicDropdownScrollbarY) + musicDropdownScrollbarHeight - 8);
                    draw_sprite(sprMakerTitleScrollbar2, _scrollInd, _left, (_top + musicDropdownScrollbarY) + roundSane(musicDropdownScrollbarHeight/2) - 17);
                }
                
                draw_set_color(c_white);
                surface_reset_target();
                
                if (surface_exists(global.sharedSurf)){
                    draw_surface_part(global.sharedSurf, 0, 0, (musicMenuWidth + (musicDropdownScrollbarWidth*musicDropdownScrollbarWidthShown)), musicDropdownHeightShown, 1600 + musicMenuLeft, 608 + (musicMenuTop + musicMenuHeightMin + 1));
                }
            }
        }
        
        // Border coordinates
        var _top = (608 + musicMenuTop);
        var _bottom = ((608 + musicMenuTop) + (musicMenuHeightMin + musicDropdownHeightShown));
        var _left = (1600 + musicMenuLeft);
        var _right = ((1600 + musicMenuLeft) + musicMenuWidth);
        if (musicDropdownScrollbarWidthShown &gt; 0){_right += (musicDropdownScrollbarWidth*musicDropdownScrollbarWidthShown);}
        
        //Draw main box
        if (selectedMenu == _musicMenu){  //  || selectedMusicRow == currentSong
            draw_set_color(selectedBoxCol);
        }else{
            draw_set_color(mainBoxCol);
        }
        draw_rectangle(_left  - 0.5, _top  - 0.5, _right  - 1.5, _top + musicMenuHeightMin  - 0.5, false);
        draw_sprite_ext(sprClearDropdownNote, 0, (_left+5) + 5, (_top+3) + 1, 2, 2, 0, c_white, 1);
        draw_sprite_ext(sprClearDropdownArrow, 0, (_right - 14)  - (4*_lerpVal), _top + 17, 1, 1, 90*(1-_lerpVal), c_white, 1);
        
        //Draw menu outline
        draw_set_color(c_black);
        //needed if the surface wasn't drawn to
        draw_set_halign(fa_left);
        draw_set_valign(fa_top);
        draw_text((_left+32), (_top+8), scrGetMusInfo(songList[currentSong], 0) + " - " + scrGetMusInfo(songList[currentSong], 1));  // Song name and author
        
        //Line between main box and dropdown menu  (covered by black border if the menu is completely minimized)
        draw_line_width(_left - 1.5, (_top + (musicMenuHeightMin))  + 0.5, _right  - 0.5, (_top + musicMenuHeightMin)  + 0.5, 2);
        
        //idk why some of these offsets are needed. I just adjusted it manually
        //draw_set_alpha(0.2);
        draw_line_width((_left - 4), (_top - 3.5), (_right + 1.5), (_top - 3.5), _borderWidth);  // top
        draw_line_width((_left - 2.5), (_top - 1.5), (_left - 2.5), (_bottom - 0.5), _borderWidth);  // left
        draw_line_width((_right - 0.5), (_top - 1.5), (_right - 0.5), (_bottom - 0.5), _borderWidth);  // right
        draw_line_width((_left - 4), (_bottom + 0.5), (_right + 1.5), (_bottom + 0.5), _borderWidth);  // bottom
        //draw_set_alpha(1);
        
        draw_set_color(c_white);
    }
}else{
    var _borderWidth = 3;
    //Music menu
    var _top = (608 + musicMenuTop);
    var _bottom = ((608 + musicMenuTop) + (musicMenuHeightMin + musicDropdownHeightShown));
    var _left = (1600 + musicMenuLeft);
    var _right = ((1600 + musicMenuLeft) + musicMenuWidth);
    if (musicDropdownScrollbarWidthShown &gt; 0){_right += (musicDropdownScrollbarWidth*musicDropdownScrollbarWidthShown);}
    draw_rectangle((_left - _borderWidth)  + drawXOff  - 0.5, (_top - _borderWidth)  + drawYOff  - 0.5, (_right + _borderWidth)  + drawXOff  - 0.5, (_bottom + _borderWidth)  + drawYOff  - 0.5, false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
